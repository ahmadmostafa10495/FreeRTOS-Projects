
RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000f5a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000e  00800060  00000f5a  00000fee  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000644  0080006e  0080006e  00000ffc  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000ffc  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000102c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000368  00000000  00000000  00001068  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000353b  00000000  00000000  000013d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000011cc  00000000  00000000  0000490b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001fb0  00000000  00000000  00005ad7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000009e0  00000000  00000000  00007a88  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000127d  00000000  00000000  00008468  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000030c8  00000000  00000000  000096e5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000328  00000000  00000000  0000c7ad  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 f5 03 	jmp	0x7ea	; 0x7ea <__vector_7>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 11 02 	jmp	0x422	; 0x422 <__vector_13>
  38:	0c 94 e8 01 	jmp	0x3d0	; 0x3d0 <__vector_14>
  3c:	0c 94 bf 01 	jmp	0x37e	; 0x37e <__vector_15>
  40:	0c 94 fa 00 	jmp	0x1f4	; 0x1f4 <__vector_16>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	ea e5       	ldi	r30, 0x5A	; 90
  68:	ff e0       	ldi	r31, 0x0F	; 15
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	ae 36       	cpi	r26, 0x6E	; 110
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	26 e0       	ldi	r18, 0x06	; 6
  78:	ae e6       	ldi	r26, 0x6E	; 110
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a2 3b       	cpi	r26, 0xB2	; 178
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 f5 00 	call	0x1ea	; 0x1ea <main>
  8a:	0c 94 ab 07 	jmp	0xf56	; 0xf56 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <init_task>:
#include "FreeRTOS.h"
#include "task.h"

/* Task to be created. */
static void init_task( void * pvParameters )
{
  92:	cf 93       	push	r28
  94:	df 93       	push	r29
  96:	1f 92       	push	r1
  98:	cd b7       	in	r28, 0x3d	; 61
  9a:	de b7       	in	r29, 0x3e	; 62
    configASSERT( ( ( uint32_t) pvParameters ) == 1 );

    for( ;; )
    {
        /* Led Init */
        LED_cfg_s_t led_info = {LED_0};
  9c:	19 82       	std	Y+1, r1	; 0x01
        Led_Init(&led_info);
  9e:	ce 01       	movw	r24, r28
  a0:	01 96       	adiw	r24, 0x01	; 1
  a2:	0e 94 84 00 	call	0x108	; 0x108 <Led_Init>
        Led_On(LED_0);
  a6:	80 e0       	ldi	r24, 0x00	; 0
  a8:	0e 94 b9 00 	call	0x172	; 0x172 <Led_On>
        vTaskSuspend(NULL);
  ac:	80 e0       	ldi	r24, 0x00	; 0
  ae:	90 e0       	ldi	r25, 0x00	; 0
  b0:	0e 94 59 07 	call	0xeb2	; 0xeb2 <vTaskSuspend>
  b4:	f3 cf       	rjmp	.-26     	; 0x9c <init_task+0xa>

000000b6 <toggle_task>:

    for( ;; )
    {
        /* Led Toggle */

        Led_Toggle(LED_0);
  b6:	80 e0       	ldi	r24, 0x00	; 0
  b8:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <Led_Toggle>
        vTaskDelay(1000/portTICK_PERIOD_MS);
  bc:	88 ee       	ldi	r24, 0xE8	; 232
  be:	93 e0       	ldi	r25, 0x03	; 3
  c0:	0e 94 df 06 	call	0xdbe	; 0xdbe <vTaskDelay>
  c4:	f8 cf       	rjmp	.-16     	; 0xb6 <toggle_task>

000000c6 <S1US1>:

    }
}

void S1US1(void)
{
  c6:	ef 92       	push	r14
  c8:	ff 92       	push	r15
  ca:	0f 93       	push	r16

    xTaskCreate(toggle_task, "LED", 100, (void *) 1, 3, NULL);
  cc:	e1 2c       	mov	r14, r1
  ce:	f1 2c       	mov	r15, r1
  d0:	03 e0       	ldi	r16, 0x03	; 3
  d2:	21 e0       	ldi	r18, 0x01	; 1
  d4:	30 e0       	ldi	r19, 0x00	; 0
  d6:	44 e6       	ldi	r20, 0x64	; 100
  d8:	50 e0       	ldi	r21, 0x00	; 0
  da:	60 e6       	ldi	r22, 0x60	; 96
  dc:	70 e0       	ldi	r23, 0x00	; 0
  de:	8b e5       	ldi	r24, 0x5B	; 91
  e0:	90 e0       	ldi	r25, 0x00	; 0
  e2:	0e 94 93 04 	call	0x926	; 0x926 <xTaskCreate>
    xTaskCreate(init_task, "INIT", 100, (void *) 1, 1, NULL);
  e6:	01 e0       	ldi	r16, 0x01	; 1
  e8:	21 e0       	ldi	r18, 0x01	; 1
  ea:	30 e0       	ldi	r19, 0x00	; 0
  ec:	44 e6       	ldi	r20, 0x64	; 100
  ee:	50 e0       	ldi	r21, 0x00	; 0
  f0:	64 e6       	ldi	r22, 0x64	; 100
  f2:	70 e0       	ldi	r23, 0x00	; 0
  f4:	89 e4       	ldi	r24, 0x49	; 73
  f6:	90 e0       	ldi	r25, 0x00	; 0
  f8:	0e 94 93 04 	call	0x926	; 0x926 <xTaskCreate>
    /* Start Scheduler */
    vTaskStartScheduler();
  fc:	0e 94 98 05 	call	0xb30	; 0xb30 <vTaskStartScheduler>

 100:	0f 91       	pop	r16
 102:	ff 90       	pop	r15
 104:	ef 90       	pop	r14
 106:	08 95       	ret

00000108 <Led_Init>:
            break;
        case (LED_2) :
            DIO_Write(LED_2_GPIO, LED_2_BIT , LOW);
            break;
        case (LED_3) :
            DIO_Write(LED_3_GPIO, LED_3_BIT , LOW);
 108:	cf 93       	push	r28
 10a:	df 93       	push	r29
 10c:	00 d0       	rcall	.+0      	; 0x10e <Led_Init+0x6>
 10e:	1f 92       	push	r1
 110:	cd b7       	in	r28, 0x3d	; 61
 112:	de b7       	in	r29, 0x3e	; 62
 114:	fc 01       	movw	r30, r24
 116:	80 81       	ld	r24, Z
 118:	81 30       	cpi	r24, 0x01	; 1
 11a:	69 f0       	breq	.+26     	; 0x136 <Led_Init+0x2e>
 11c:	28 f0       	brcs	.+10     	; 0x128 <Led_Init+0x20>
 11e:	82 30       	cpi	r24, 0x02	; 2
 120:	89 f0       	breq	.+34     	; 0x144 <Led_Init+0x3c>
 122:	83 30       	cpi	r24, 0x03	; 3
 124:	b1 f0       	breq	.+44     	; 0x152 <Led_Init+0x4a>
 126:	1b c0       	rjmp	.+54     	; 0x15e <Led_Init+0x56>
 128:	81 e0       	ldi	r24, 0x01	; 1
 12a:	89 83       	std	Y+1, r24	; 0x01
 12c:	80 e1       	ldi	r24, 0x10	; 16
 12e:	8a 83       	std	Y+2, r24	; 0x02
 130:	8f ef       	ldi	r24, 0xFF	; 255
 132:	8b 83       	std	Y+3, r24	; 0x03
 134:	14 c0       	rjmp	.+40     	; 0x15e <Led_Init+0x56>
 136:	81 e0       	ldi	r24, 0x01	; 1
 138:	89 83       	std	Y+1, r24	; 0x01
 13a:	80 e2       	ldi	r24, 0x20	; 32
 13c:	8a 83       	std	Y+2, r24	; 0x02
 13e:	8f ef       	ldi	r24, 0xFF	; 255
 140:	8b 83       	std	Y+3, r24	; 0x03
 142:	0d c0       	rjmp	.+26     	; 0x15e <Led_Init+0x56>
 144:	81 e0       	ldi	r24, 0x01	; 1
 146:	89 83       	std	Y+1, r24	; 0x01
 148:	80 e4       	ldi	r24, 0x40	; 64
 14a:	8a 83       	std	Y+2, r24	; 0x02
 14c:	8f ef       	ldi	r24, 0xFF	; 255
 14e:	8b 83       	std	Y+3, r24	; 0x03
 150:	06 c0       	rjmp	.+12     	; 0x15e <Led_Init+0x56>
 152:	81 e0       	ldi	r24, 0x01	; 1
 154:	89 83       	std	Y+1, r24	; 0x01
 156:	80 e8       	ldi	r24, 0x80	; 128
 158:	8a 83       	std	Y+2, r24	; 0x02
 15a:	8f ef       	ldi	r24, 0xFF	; 255
 15c:	8b 83       	std	Y+3, r24	; 0x03
 15e:	ce 01       	movw	r24, r28
 160:	01 96       	adiw	r24, 0x01	; 1
 162:	0e 94 23 01 	call	0x246	; 0x246 <DIO_init>
 166:	0f 90       	pop	r0
 168:	0f 90       	pop	r0
 16a:	0f 90       	pop	r0
 16c:	df 91       	pop	r29
 16e:	cf 91       	pop	r28
 170:	08 95       	ret

00000172 <Led_On>:
 172:	81 30       	cpi	r24, 0x01	; 1
 174:	61 f0       	breq	.+24     	; 0x18e <Led_On+0x1c>
 176:	28 f0       	brcs	.+10     	; 0x182 <Led_On+0x10>
 178:	82 30       	cpi	r24, 0x02	; 2
 17a:	79 f0       	breq	.+30     	; 0x19a <Led_On+0x28>
 17c:	83 30       	cpi	r24, 0x03	; 3
 17e:	99 f0       	breq	.+38     	; 0x1a6 <Led_On+0x34>
 180:	08 95       	ret
 182:	4f ef       	ldi	r20, 0xFF	; 255
 184:	60 e1       	ldi	r22, 0x10	; 16
 186:	81 e0       	ldi	r24, 0x01	; 1
 188:	0e 94 63 01 	call	0x2c6	; 0x2c6 <DIO_Write>
 18c:	08 95       	ret
 18e:	4f ef       	ldi	r20, 0xFF	; 255
 190:	60 e2       	ldi	r22, 0x20	; 32
 192:	81 e0       	ldi	r24, 0x01	; 1
 194:	0e 94 63 01 	call	0x2c6	; 0x2c6 <DIO_Write>
 198:	08 95       	ret
 19a:	4f ef       	ldi	r20, 0xFF	; 255
 19c:	60 e4       	ldi	r22, 0x40	; 64
 19e:	81 e0       	ldi	r24, 0x01	; 1
 1a0:	0e 94 63 01 	call	0x2c6	; 0x2c6 <DIO_Write>
 1a4:	08 95       	ret
 1a6:	4f ef       	ldi	r20, 0xFF	; 255
 1a8:	60 e8       	ldi	r22, 0x80	; 128
 1aa:	81 e0       	ldi	r24, 0x01	; 1
 1ac:	0e 94 63 01 	call	0x2c6	; 0x2c6 <DIO_Write>
 1b0:	08 95       	ret

000001b2 <Led_Toggle>:
    }
}


void Led_Toggle(uint8 led_id){
    switch(led_id){
 1b2:	81 30       	cpi	r24, 0x01	; 1
 1b4:	59 f0       	breq	.+22     	; 0x1cc <Led_Toggle+0x1a>
 1b6:	28 f0       	brcs	.+10     	; 0x1c2 <Led_Toggle+0x10>
 1b8:	82 30       	cpi	r24, 0x02	; 2
 1ba:	69 f0       	breq	.+26     	; 0x1d6 <Led_Toggle+0x24>
 1bc:	83 30       	cpi	r24, 0x03	; 3
 1be:	81 f0       	breq	.+32     	; 0x1e0 <Led_Toggle+0x2e>
 1c0:	08 95       	ret
        case (LED_0) :
            DIO_Toggle(LED_0_GPIO, LED_0_BIT );
 1c2:	60 e1       	ldi	r22, 0x10	; 16
 1c4:	81 e0       	ldi	r24, 0x01	; 1
 1c6:	0e 94 91 01 	call	0x322	; 0x322 <DIO_Toggle>
            break;
 1ca:	08 95       	ret
        case (LED_1) :
            DIO_Toggle(LED_1_GPIO, LED_1_BIT );
 1cc:	60 e2       	ldi	r22, 0x20	; 32
 1ce:	81 e0       	ldi	r24, 0x01	; 1
 1d0:	0e 94 91 01 	call	0x322	; 0x322 <DIO_Toggle>
            break;
 1d4:	08 95       	ret
        case (LED_2) :
            DIO_Toggle(LED_2_GPIO, LED_2_BIT );
 1d6:	60 e4       	ldi	r22, 0x40	; 64
 1d8:	81 e0       	ldi	r24, 0x01	; 1
 1da:	0e 94 91 01 	call	0x322	; 0x322 <DIO_Toggle>
            break;
 1de:	08 95       	ret
        case (LED_3) :
            DIO_Toggle(LED_3_GPIO, LED_3_BIT );
 1e0:	60 e8       	ldi	r22, 0x80	; 128
 1e2:	81 e0       	ldi	r24, 0x01	; 1
 1e4:	0e 94 91 01 	call	0x322	; 0x322 <DIO_Toggle>
 1e8:	08 95       	ret

000001ea <main>:

#include "S1US1.h"

int main(void)
{
    S1US1();
 1ea:	0e 94 63 00 	call	0xc6	; 0xc6 <S1US1>
}
 1ee:	80 e0       	ldi	r24, 0x00	; 0
 1f0:	90 e0       	ldi	r25, 0x00	; 0
 1f2:	08 95       	ret

000001f4 <__vector_16>:
    return errorStatus;

}

ISR(ADC_vect)
{
 1f4:	1f 92       	push	r1
 1f6:	0f 92       	push	r0
 1f8:	0f b6       	in	r0, 0x3f	; 63
 1fa:	0f 92       	push	r0
 1fc:	11 24       	eor	r1, r1
 1fe:	2f 93       	push	r18
 200:	3f 93       	push	r19
 202:	4f 93       	push	r20
 204:	5f 93       	push	r21
 206:	6f 93       	push	r22
 208:	7f 93       	push	r23
 20a:	8f 93       	push	r24
 20c:	9f 93       	push	r25
 20e:	af 93       	push	r26
 210:	bf 93       	push	r27
 212:	ef 93       	push	r30
 214:	ff 93       	push	r31
    if(ADC_CBK_Ptr != NULL)
 216:	e0 91 6e 00 	lds	r30, 0x006E	; 0x80006e <__data_end>
 21a:	f0 91 6f 00 	lds	r31, 0x006F	; 0x80006f <__data_end+0x1>
 21e:	30 97       	sbiw	r30, 0x00	; 0
 220:	09 f0       	breq	.+2      	; 0x224 <__vector_16+0x30>
    {
        ADC_CBK_Ptr();
 222:	09 95       	icall
    }

 224:	ff 91       	pop	r31
 226:	ef 91       	pop	r30
 228:	bf 91       	pop	r27
 22a:	af 91       	pop	r26
 22c:	9f 91       	pop	r25
 22e:	8f 91       	pop	r24
 230:	7f 91       	pop	r23
 232:	6f 91       	pop	r22
 234:	5f 91       	pop	r21
 236:	4f 91       	pop	r20
 238:	3f 91       	pop	r19
 23a:	2f 91       	pop	r18
 23c:	0f 90       	pop	r0
 23e:	0f be       	out	0x3f, r0	; 63
 240:	0f 90       	pop	r0
 242:	1f 90       	pop	r1
 244:	18 95       	reti

00000246 <DIO_init>:
        errorStatus = E_NOK;
    }

    return errorStatus;

}
 246:	fc 01       	movw	r30, r24
 248:	89 2b       	or	r24, r25
 24a:	c9 f1       	breq	.+114    	; 0x2be <DIO_init+0x78>
 24c:	80 81       	ld	r24, Z
 24e:	81 30       	cpi	r24, 0x01	; 1
 250:	91 f0       	breq	.+36     	; 0x276 <DIO_init+0x30>
 252:	28 f0       	brcs	.+10     	; 0x25e <DIO_init+0x18>
 254:	82 30       	cpi	r24, 0x02	; 2
 256:	d9 f0       	breq	.+54     	; 0x28e <DIO_init+0x48>
 258:	83 30       	cpi	r24, 0x03	; 3
 25a:	29 f1       	breq	.+74     	; 0x2a6 <DIO_init+0x60>
 25c:	32 c0       	rjmp	.+100    	; 0x2c2 <DIO_init+0x7c>
 25e:	21 81       	ldd	r18, Z+1	; 0x01
 260:	9a b3       	in	r25, 0x1a	; 26
 262:	82 81       	ldd	r24, Z+2	; 0x02
 264:	32 2f       	mov	r19, r18
 266:	38 23       	and	r19, r24
 268:	82 2f       	mov	r24, r18
 26a:	80 95       	com	r24
 26c:	89 23       	and	r24, r25
 26e:	83 2b       	or	r24, r19
 270:	8a bb       	out	0x1a, r24	; 26
 272:	80 e0       	ldi	r24, 0x00	; 0
 274:	08 95       	ret
 276:	21 81       	ldd	r18, Z+1	; 0x01
 278:	97 b3       	in	r25, 0x17	; 23
 27a:	82 81       	ldd	r24, Z+2	; 0x02
 27c:	32 2f       	mov	r19, r18
 27e:	38 23       	and	r19, r24
 280:	82 2f       	mov	r24, r18
 282:	80 95       	com	r24
 284:	89 23       	and	r24, r25
 286:	83 2b       	or	r24, r19
 288:	87 bb       	out	0x17, r24	; 23
 28a:	80 e0       	ldi	r24, 0x00	; 0
 28c:	08 95       	ret
 28e:	21 81       	ldd	r18, Z+1	; 0x01
 290:	94 b3       	in	r25, 0x14	; 20
 292:	82 81       	ldd	r24, Z+2	; 0x02
 294:	32 2f       	mov	r19, r18
 296:	38 23       	and	r19, r24
 298:	82 2f       	mov	r24, r18
 29a:	80 95       	com	r24
 29c:	89 23       	and	r24, r25
 29e:	83 2b       	or	r24, r19
 2a0:	84 bb       	out	0x14, r24	; 20
 2a2:	80 e0       	ldi	r24, 0x00	; 0
 2a4:	08 95       	ret
 2a6:	21 81       	ldd	r18, Z+1	; 0x01
 2a8:	91 b3       	in	r25, 0x11	; 17
 2aa:	82 81       	ldd	r24, Z+2	; 0x02
 2ac:	32 2f       	mov	r19, r18
 2ae:	38 23       	and	r19, r24
 2b0:	82 2f       	mov	r24, r18
 2b2:	80 95       	com	r24
 2b4:	89 23       	and	r24, r25
 2b6:	83 2b       	or	r24, r19
 2b8:	81 bb       	out	0x11, r24	; 17
 2ba:	80 e0       	ldi	r24, 0x00	; 0
 2bc:	08 95       	ret
 2be:	81 e0       	ldi	r24, 0x01	; 1
 2c0:	08 95       	ret
 2c2:	81 e0       	ldi	r24, 0x01	; 1
 2c4:	08 95       	ret

000002c6 <DIO_Write>:
 2c6:	81 30       	cpi	r24, 0x01	; 1
 2c8:	79 f0       	breq	.+30     	; 0x2e8 <DIO_Write+0x22>
 2ca:	28 f0       	brcs	.+10     	; 0x2d6 <DIO_Write+0x10>
 2cc:	82 30       	cpi	r24, 0x02	; 2
 2ce:	a9 f0       	breq	.+42     	; 0x2fa <DIO_Write+0x34>
 2d0:	83 30       	cpi	r24, 0x03	; 3
 2d2:	e1 f0       	breq	.+56     	; 0x30c <DIO_Write+0x46>
 2d4:	24 c0       	rjmp	.+72     	; 0x31e <DIO_Write+0x58>
 2d6:	8b b3       	in	r24, 0x1b	; 27
 2d8:	96 2f       	mov	r25, r22
 2da:	90 95       	com	r25
 2dc:	89 23       	and	r24, r25
 2de:	46 23       	and	r20, r22
 2e0:	48 2b       	or	r20, r24
 2e2:	4b bb       	out	0x1b, r20	; 27
 2e4:	80 e0       	ldi	r24, 0x00	; 0
 2e6:	08 95       	ret
 2e8:	88 b3       	in	r24, 0x18	; 24
 2ea:	96 2f       	mov	r25, r22
 2ec:	90 95       	com	r25
 2ee:	89 23       	and	r24, r25
 2f0:	46 23       	and	r20, r22
 2f2:	48 2b       	or	r20, r24
 2f4:	48 bb       	out	0x18, r20	; 24
 2f6:	80 e0       	ldi	r24, 0x00	; 0
 2f8:	08 95       	ret
 2fa:	85 b3       	in	r24, 0x15	; 21
 2fc:	96 2f       	mov	r25, r22
 2fe:	90 95       	com	r25
 300:	89 23       	and	r24, r25
 302:	46 23       	and	r20, r22
 304:	48 2b       	or	r20, r24
 306:	45 bb       	out	0x15, r20	; 21
 308:	80 e0       	ldi	r24, 0x00	; 0
 30a:	08 95       	ret
 30c:	82 b3       	in	r24, 0x12	; 18
 30e:	96 2f       	mov	r25, r22
 310:	90 95       	com	r25
 312:	89 23       	and	r24, r25
 314:	46 23       	and	r20, r22
 316:	48 2b       	or	r20, r24
 318:	42 bb       	out	0x12, r20	; 18
 31a:	80 e0       	ldi	r24, 0x00	; 0
 31c:	08 95       	ret
 31e:	81 e0       	ldi	r24, 0x01	; 1
 320:	08 95       	ret

00000322 <DIO_Toggle>:
 *               or even one pin.
 */
ERROR_STATUS DIO_Toggle (uint8 GPIO, uint8 pins)
{
    ERROR_STATUS errorStatus = E_NOK;
    switch(GPIO)
 322:	81 30       	cpi	r24, 0x01	; 1
 324:	79 f0       	breq	.+30     	; 0x344 <DIO_Toggle+0x22>
 326:	28 f0       	brcs	.+10     	; 0x332 <DIO_Toggle+0x10>
 328:	82 30       	cpi	r24, 0x02	; 2
 32a:	a9 f0       	breq	.+42     	; 0x356 <DIO_Toggle+0x34>
 32c:	83 30       	cpi	r24, 0x03	; 3
 32e:	e1 f0       	breq	.+56     	; 0x368 <DIO_Toggle+0x46>
 330:	24 c0       	rjmp	.+72     	; 0x37a <DIO_Toggle+0x58>
    {
    case GPIOA :
        PORTA_DATA = (pins & (~PORTA_DATA)) | (~pins & PORTA_DATA);
 332:	8b b3       	in	r24, 0x1b	; 27
 334:	9b b3       	in	r25, 0x1b	; 27
 336:	80 95       	com	r24
 338:	89 27       	eor	r24, r25
 33a:	68 23       	and	r22, r24
 33c:	69 27       	eor	r22, r25
 33e:	6b bb       	out	0x1b, r22	; 27
        errorStatus = E_OK;
 340:	80 e0       	ldi	r24, 0x00	; 0
        break;
 342:	08 95       	ret
    case GPIOB :
        PORTB_DATA = (pins & (~PORTB_DATA)) | (~pins & PORTB_DATA);
 344:	88 b3       	in	r24, 0x18	; 24
 346:	98 b3       	in	r25, 0x18	; 24
 348:	80 95       	com	r24
 34a:	89 27       	eor	r24, r25
 34c:	68 23       	and	r22, r24
 34e:	69 27       	eor	r22, r25
 350:	68 bb       	out	0x18, r22	; 24
        errorStatus = E_OK;
 352:	80 e0       	ldi	r24, 0x00	; 0
        break;
 354:	08 95       	ret
    case GPIOC :
        PORTC_DATA = (pins & (~PORTC_DATA)) | (~pins & PORTC_DATA);
 356:	85 b3       	in	r24, 0x15	; 21
 358:	95 b3       	in	r25, 0x15	; 21
 35a:	80 95       	com	r24
 35c:	89 27       	eor	r24, r25
 35e:	68 23       	and	r22, r24
 360:	69 27       	eor	r22, r25
 362:	65 bb       	out	0x15, r22	; 21
        errorStatus = E_OK;
 364:	80 e0       	ldi	r24, 0x00	; 0
        break;
 366:	08 95       	ret
    case GPIOD :
        PORTD_DATA = (pins & (~PORTD_DATA)) | (~pins & PORTD_DATA);
 368:	82 b3       	in	r24, 0x12	; 18
 36a:	92 b3       	in	r25, 0x12	; 18
 36c:	80 95       	com	r24
 36e:	89 27       	eor	r24, r25
 370:	68 23       	and	r22, r24
 372:	69 27       	eor	r22, r25
 374:	62 bb       	out	0x12, r22	; 18
        errorStatus = E_OK;
 376:	80 e0       	ldi	r24, 0x00	; 0
        break;
 378:	08 95       	ret
    default :
        errorStatus = E_NOK;
 37a:	81 e0       	ldi	r24, 0x01	; 1
        break;
    }
    return errorStatus;
}
 37c:	08 95       	ret

0000037e <__vector_15>:
    }
    return E_OK;
}

ISR(USART_TXC_vect)
{
 37e:	1f 92       	push	r1
 380:	0f 92       	push	r0
 382:	0f b6       	in	r0, 0x3f	; 63
 384:	0f 92       	push	r0
 386:	11 24       	eor	r1, r1
 388:	2f 93       	push	r18
 38a:	3f 93       	push	r19
 38c:	4f 93       	push	r20
 38e:	5f 93       	push	r21
 390:	6f 93       	push	r22
 392:	7f 93       	push	r23
 394:	8f 93       	push	r24
 396:	9f 93       	push	r25
 398:	af 93       	push	r26
 39a:	bf 93       	push	r27
 39c:	ef 93       	push	r30
 39e:	ff 93       	push	r31
    if (NULL != Transmitter_Cbk_ptr)
 3a0:	e0 91 74 00 	lds	r30, 0x0074	; 0x800074 <Transmitter_Cbk_ptr>
 3a4:	f0 91 75 00 	lds	r31, 0x0075	; 0x800075 <Transmitter_Cbk_ptr+0x1>
 3a8:	30 97       	sbiw	r30, 0x00	; 0
 3aa:	09 f0       	breq	.+2      	; 0x3ae <__vector_15+0x30>
    {
        Transmitter_Cbk_ptr();
 3ac:	09 95       	icall
    } 
    else
    {
        
    }
}
 3ae:	ff 91       	pop	r31
 3b0:	ef 91       	pop	r30
 3b2:	bf 91       	pop	r27
 3b4:	af 91       	pop	r26
 3b6:	9f 91       	pop	r25
 3b8:	8f 91       	pop	r24
 3ba:	7f 91       	pop	r23
 3bc:	6f 91       	pop	r22
 3be:	5f 91       	pop	r21
 3c0:	4f 91       	pop	r20
 3c2:	3f 91       	pop	r19
 3c4:	2f 91       	pop	r18
 3c6:	0f 90       	pop	r0
 3c8:	0f be       	out	0x3f, r0	; 63
 3ca:	0f 90       	pop	r0
 3cc:	1f 90       	pop	r1
 3ce:	18 95       	reti

000003d0 <__vector_14>:

ISR(USART_UDRE_vect)
{
 3d0:	1f 92       	push	r1
 3d2:	0f 92       	push	r0
 3d4:	0f b6       	in	r0, 0x3f	; 63
 3d6:	0f 92       	push	r0
 3d8:	11 24       	eor	r1, r1
 3da:	2f 93       	push	r18
 3dc:	3f 93       	push	r19
 3de:	4f 93       	push	r20
 3e0:	5f 93       	push	r21
 3e2:	6f 93       	push	r22
 3e4:	7f 93       	push	r23
 3e6:	8f 93       	push	r24
 3e8:	9f 93       	push	r25
 3ea:	af 93       	push	r26
 3ec:	bf 93       	push	r27
 3ee:	ef 93       	push	r30
 3f0:	ff 93       	push	r31
    if (NULL != DataRegisterEmpty_Cbk_ptr)
 3f2:	e0 91 70 00 	lds	r30, 0x0070	; 0x800070 <DataRegisterEmpty_Cbk_ptr>
 3f6:	f0 91 71 00 	lds	r31, 0x0071	; 0x800071 <DataRegisterEmpty_Cbk_ptr+0x1>
 3fa:	30 97       	sbiw	r30, 0x00	; 0
 3fc:	09 f0       	breq	.+2      	; 0x400 <__LOCK_REGION_LENGTH__>
    {
        DataRegisterEmpty_Cbk_ptr();
 3fe:	09 95       	icall
    }
    else
    {
        
    }
}
 400:	ff 91       	pop	r31
 402:	ef 91       	pop	r30
 404:	bf 91       	pop	r27
 406:	af 91       	pop	r26
 408:	9f 91       	pop	r25
 40a:	8f 91       	pop	r24
 40c:	7f 91       	pop	r23
 40e:	6f 91       	pop	r22
 410:	5f 91       	pop	r21
 412:	4f 91       	pop	r20
 414:	3f 91       	pop	r19
 416:	2f 91       	pop	r18
 418:	0f 90       	pop	r0
 41a:	0f be       	out	0x3f, r0	; 63
 41c:	0f 90       	pop	r0
 41e:	1f 90       	pop	r1
 420:	18 95       	reti

00000422 <__vector_13>:

ISR(USART_RXC_vect)
{
 422:	1f 92       	push	r1
 424:	0f 92       	push	r0
 426:	0f b6       	in	r0, 0x3f	; 63
 428:	0f 92       	push	r0
 42a:	11 24       	eor	r1, r1
 42c:	2f 93       	push	r18
 42e:	3f 93       	push	r19
 430:	4f 93       	push	r20
 432:	5f 93       	push	r21
 434:	6f 93       	push	r22
 436:	7f 93       	push	r23
 438:	8f 93       	push	r24
 43a:	9f 93       	push	r25
 43c:	af 93       	push	r26
 43e:	bf 93       	push	r27
 440:	ef 93       	push	r30
 442:	ff 93       	push	r31
    if (NULL != Receiver_Cbk_ptr)
 444:	e0 91 72 00 	lds	r30, 0x0072	; 0x800072 <Receiver_Cbk_ptr>
 448:	f0 91 73 00 	lds	r31, 0x0073	; 0x800073 <Receiver_Cbk_ptr+0x1>
 44c:	30 97       	sbiw	r30, 0x00	; 0
 44e:	09 f0       	breq	.+2      	; 0x452 <__vector_13+0x30>
    {
        Receiver_Cbk_ptr();
 450:	09 95       	icall
    }
    else
    {
        
    }
}
 452:	ff 91       	pop	r31
 454:	ef 91       	pop	r30
 456:	bf 91       	pop	r27
 458:	af 91       	pop	r26
 45a:	9f 91       	pop	r25
 45c:	8f 91       	pop	r24
 45e:	7f 91       	pop	r23
 460:	6f 91       	pop	r22
 462:	5f 91       	pop	r21
 464:	4f 91       	pop	r20
 466:	3f 91       	pop	r19
 468:	2f 91       	pop	r18
 46a:	0f 90       	pop	r0
 46c:	0f be       	out	0x3f, r0	; 63
 46e:	0f 90       	pop	r0
 470:	1f 90       	pop	r1
 472:	18 95       	reti

00000474 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 474:	cf 93       	push	r28
 476:	df 93       	push	r29
 478:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
 47a:	0e 94 c2 05 	call	0xb84	; 0xb84 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
 47e:	80 91 76 00 	lds	r24, 0x0076	; 0x800076 <pucAlignedHeap.2096>
 482:	90 91 77 00 	lds	r25, 0x0077	; 0x800077 <pucAlignedHeap.2096+0x1>
 486:	89 2b       	or	r24, r25
 488:	31 f4       	brne	.+12     	; 0x496 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 48a:	8b e7       	ldi	r24, 0x7B	; 123
 48c:	90 e0       	ldi	r25, 0x00	; 0
 48e:	90 93 77 00 	sts	0x0077, r25	; 0x800077 <pucAlignedHeap.2096+0x1>
 492:	80 93 76 00 	sts	0x0076, r24	; 0x800076 <pucAlignedHeap.2096>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 496:	20 91 78 00 	lds	r18, 0x0078	; 0x800078 <xNextFreeByte>
 49a:	30 91 79 00 	lds	r19, 0x0079	; 0x800079 <xNextFreeByte+0x1>
 49e:	c9 01       	movw	r24, r18
 4a0:	8c 0f       	add	r24, r28
 4a2:	9d 1f       	adc	r25, r29
 4a4:	8b 3d       	cpi	r24, 0xDB	; 219
 4a6:	45 e0       	ldi	r20, 0x05	; 5
 4a8:	94 07       	cpc	r25, r20
 4aa:	70 f4       	brcc	.+28     	; 0x4c8 <pvPortMalloc+0x54>
 4ac:	28 17       	cp	r18, r24
 4ae:	39 07       	cpc	r19, r25
 4b0:	70 f4       	brcc	.+28     	; 0x4ce <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 4b2:	c0 91 76 00 	lds	r28, 0x0076	; 0x800076 <pucAlignedHeap.2096>
 4b6:	d0 91 77 00 	lds	r29, 0x0077	; 0x800077 <pucAlignedHeap.2096+0x1>
 4ba:	c2 0f       	add	r28, r18
 4bc:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
 4be:	90 93 79 00 	sts	0x0079, r25	; 0x800079 <xNextFreeByte+0x1>
 4c2:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <xNextFreeByte>
 4c6:	05 c0       	rjmp	.+10     	; 0x4d2 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
 4c8:	c0 e0       	ldi	r28, 0x00	; 0
 4ca:	d0 e0       	ldi	r29, 0x00	; 0
 4cc:	02 c0       	rjmp	.+4      	; 0x4d2 <pvPortMalloc+0x5e>
 4ce:	c0 e0       	ldi	r28, 0x00	; 0
 4d0:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 4d2:	0e 94 68 06 	call	0xcd0	; 0xcd0 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 4d6:	ce 01       	movw	r24, r28
 4d8:	df 91       	pop	r29
 4da:	cf 91       	pop	r28
 4dc:	08 95       	ret

000004de <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 4de:	08 95       	ret

000004e0 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 4e0:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 4e2:	03 96       	adiw	r24, 0x03	; 3
 4e4:	92 83       	std	Z+2, r25	; 0x02
 4e6:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 4e8:	2f ef       	ldi	r18, 0xFF	; 255
 4ea:	3f ef       	ldi	r19, 0xFF	; 255
 4ec:	34 83       	std	Z+4, r19	; 0x04
 4ee:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 4f0:	96 83       	std	Z+6, r25	; 0x06
 4f2:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 4f4:	90 87       	std	Z+8, r25	; 0x08
 4f6:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 4f8:	10 82       	st	Z, r1
 4fa:	08 95       	ret

000004fc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
 4fc:	fc 01       	movw	r30, r24
 4fe:	11 86       	std	Z+9, r1	; 0x09
 500:	10 86       	std	Z+8, r1	; 0x08
 502:	08 95       	ret

00000504 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 504:	cf 93       	push	r28
 506:	df 93       	push	r29
 508:	9c 01       	movw	r18, r24
 50a:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
 50c:	dc 01       	movw	r26, r24
 50e:	11 96       	adiw	r26, 0x01	; 1
 510:	cd 91       	ld	r28, X+
 512:	dc 91       	ld	r29, X
 514:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 516:	d3 83       	std	Z+3, r29	; 0x03
 518:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 51a:	8c 81       	ldd	r24, Y+4	; 0x04
 51c:	9d 81       	ldd	r25, Y+5	; 0x05
 51e:	95 83       	std	Z+5, r25	; 0x05
 520:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 522:	8c 81       	ldd	r24, Y+4	; 0x04
 524:	9d 81       	ldd	r25, Y+5	; 0x05
 526:	dc 01       	movw	r26, r24
 528:	13 96       	adiw	r26, 0x03	; 3
 52a:	7c 93       	st	X, r23
 52c:	6e 93       	st	-X, r22
 52e:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
 530:	7d 83       	std	Y+5, r23	; 0x05
 532:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
 534:	31 87       	std	Z+9, r19	; 0x09
 536:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
 538:	f9 01       	movw	r30, r18
 53a:	80 81       	ld	r24, Z
 53c:	8f 5f       	subi	r24, 0xFF	; 255
 53e:	80 83       	st	Z, r24
}
 540:	df 91       	pop	r29
 542:	cf 91       	pop	r28
 544:	08 95       	ret

00000546 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 546:	cf 93       	push	r28
 548:	df 93       	push	r29
 54a:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 54c:	48 81       	ld	r20, Y
 54e:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 550:	4f 3f       	cpi	r20, 0xFF	; 255
 552:	2f ef       	ldi	r18, 0xFF	; 255
 554:	52 07       	cpc	r21, r18
 556:	21 f4       	brne	.+8      	; 0x560 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 558:	fc 01       	movw	r30, r24
 55a:	a7 81       	ldd	r26, Z+7	; 0x07
 55c:	b0 85       	ldd	r27, Z+8	; 0x08
 55e:	0d c0       	rjmp	.+26     	; 0x57a <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 560:	dc 01       	movw	r26, r24
 562:	13 96       	adiw	r26, 0x03	; 3
 564:	01 c0       	rjmp	.+2      	; 0x568 <vListInsert+0x22>
 566:	df 01       	movw	r26, r30
 568:	12 96       	adiw	r26, 0x02	; 2
 56a:	ed 91       	ld	r30, X+
 56c:	fc 91       	ld	r31, X
 56e:	13 97       	sbiw	r26, 0x03	; 3
 570:	20 81       	ld	r18, Z
 572:	31 81       	ldd	r19, Z+1	; 0x01
 574:	42 17       	cp	r20, r18
 576:	53 07       	cpc	r21, r19
 578:	b0 f7       	brcc	.-20     	; 0x566 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 57a:	12 96       	adiw	r26, 0x02	; 2
 57c:	ed 91       	ld	r30, X+
 57e:	fc 91       	ld	r31, X
 580:	13 97       	sbiw	r26, 0x03	; 3
 582:	fb 83       	std	Y+3, r31	; 0x03
 584:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 586:	d5 83       	std	Z+5, r29	; 0x05
 588:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
 58a:	bd 83       	std	Y+5, r27	; 0x05
 58c:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
 58e:	13 96       	adiw	r26, 0x03	; 3
 590:	dc 93       	st	X, r29
 592:	ce 93       	st	-X, r28
 594:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
 596:	99 87       	std	Y+9, r25	; 0x09
 598:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 59a:	fc 01       	movw	r30, r24
 59c:	20 81       	ld	r18, Z
 59e:	2f 5f       	subi	r18, 0xFF	; 255
 5a0:	20 83       	st	Z, r18
}
 5a2:	df 91       	pop	r29
 5a4:	cf 91       	pop	r28
 5a6:	08 95       	ret

000005a8 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 5a8:	cf 93       	push	r28
 5aa:	df 93       	push	r29
 5ac:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
 5ae:	a0 85       	ldd	r26, Z+8	; 0x08
 5b0:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 5b2:	c2 81       	ldd	r28, Z+2	; 0x02
 5b4:	d3 81       	ldd	r29, Z+3	; 0x03
 5b6:	84 81       	ldd	r24, Z+4	; 0x04
 5b8:	95 81       	ldd	r25, Z+5	; 0x05
 5ba:	9d 83       	std	Y+5, r25	; 0x05
 5bc:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 5be:	c4 81       	ldd	r28, Z+4	; 0x04
 5c0:	d5 81       	ldd	r29, Z+5	; 0x05
 5c2:	82 81       	ldd	r24, Z+2	; 0x02
 5c4:	93 81       	ldd	r25, Z+3	; 0x03
 5c6:	9b 83       	std	Y+3, r25	; 0x03
 5c8:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 5ca:	11 96       	adiw	r26, 0x01	; 1
 5cc:	8d 91       	ld	r24, X+
 5ce:	9c 91       	ld	r25, X
 5d0:	12 97       	sbiw	r26, 0x02	; 2
 5d2:	e8 17       	cp	r30, r24
 5d4:	f9 07       	cpc	r31, r25
 5d6:	31 f4       	brne	.+12     	; 0x5e4 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 5d8:	84 81       	ldd	r24, Z+4	; 0x04
 5da:	95 81       	ldd	r25, Z+5	; 0x05
 5dc:	12 96       	adiw	r26, 0x02	; 2
 5de:	9c 93       	st	X, r25
 5e0:	8e 93       	st	-X, r24
 5e2:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
 5e4:	11 86       	std	Z+9, r1	; 0x09
 5e6:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 5e8:	8c 91       	ld	r24, X
 5ea:	81 50       	subi	r24, 0x01	; 1
 5ec:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
 5ee:	8c 91       	ld	r24, X
}
 5f0:	df 91       	pop	r29
 5f2:	cf 91       	pop	r28
 5f4:	08 95       	ret

000005f6 <pxPortInitialiseStack>:
	{
		vTaskSwitchContext();
	}
	portRESTORE_CONTEXT();

	asm volatile ( "ret" );
 5f6:	31 e1       	ldi	r19, 0x11	; 17
 5f8:	fc 01       	movw	r30, r24
 5fa:	30 83       	st	Z, r19
 5fc:	31 97       	sbiw	r30, 0x01	; 1
 5fe:	22 e2       	ldi	r18, 0x22	; 34
 600:	20 83       	st	Z, r18
 602:	31 97       	sbiw	r30, 0x01	; 1
 604:	a3 e3       	ldi	r26, 0x33	; 51
 606:	a0 83       	st	Z, r26
 608:	31 97       	sbiw	r30, 0x01	; 1
 60a:	60 83       	st	Z, r22
 60c:	31 97       	sbiw	r30, 0x01	; 1
 60e:	70 83       	st	Z, r23
 610:	31 97       	sbiw	r30, 0x01	; 1
 612:	10 82       	st	Z, r1
 614:	31 97       	sbiw	r30, 0x01	; 1
 616:	60 e8       	ldi	r22, 0x80	; 128
 618:	60 83       	st	Z, r22
 61a:	31 97       	sbiw	r30, 0x01	; 1
 61c:	10 82       	st	Z, r1
 61e:	31 97       	sbiw	r30, 0x01	; 1
 620:	62 e0       	ldi	r22, 0x02	; 2
 622:	60 83       	st	Z, r22
 624:	31 97       	sbiw	r30, 0x01	; 1
 626:	63 e0       	ldi	r22, 0x03	; 3
 628:	60 83       	st	Z, r22
 62a:	31 97       	sbiw	r30, 0x01	; 1
 62c:	64 e0       	ldi	r22, 0x04	; 4
 62e:	60 83       	st	Z, r22
 630:	31 97       	sbiw	r30, 0x01	; 1
 632:	65 e0       	ldi	r22, 0x05	; 5
 634:	60 83       	st	Z, r22
 636:	31 97       	sbiw	r30, 0x01	; 1
 638:	66 e0       	ldi	r22, 0x06	; 6
 63a:	60 83       	st	Z, r22
 63c:	31 97       	sbiw	r30, 0x01	; 1
 63e:	67 e0       	ldi	r22, 0x07	; 7
 640:	60 83       	st	Z, r22
 642:	31 97       	sbiw	r30, 0x01	; 1
 644:	68 e0       	ldi	r22, 0x08	; 8
 646:	60 83       	st	Z, r22
 648:	31 97       	sbiw	r30, 0x01	; 1
 64a:	69 e0       	ldi	r22, 0x09	; 9
 64c:	60 83       	st	Z, r22
 64e:	31 97       	sbiw	r30, 0x01	; 1
 650:	60 e1       	ldi	r22, 0x10	; 16
 652:	60 83       	st	Z, r22
 654:	31 97       	sbiw	r30, 0x01	; 1
 656:	30 83       	st	Z, r19
 658:	31 97       	sbiw	r30, 0x01	; 1
 65a:	32 e1       	ldi	r19, 0x12	; 18
 65c:	30 83       	st	Z, r19
 65e:	31 97       	sbiw	r30, 0x01	; 1
 660:	33 e1       	ldi	r19, 0x13	; 19
 662:	30 83       	st	Z, r19
 664:	31 97       	sbiw	r30, 0x01	; 1
 666:	34 e1       	ldi	r19, 0x14	; 20
 668:	30 83       	st	Z, r19
 66a:	31 97       	sbiw	r30, 0x01	; 1
 66c:	35 e1       	ldi	r19, 0x15	; 21
 66e:	30 83       	st	Z, r19
 670:	31 97       	sbiw	r30, 0x01	; 1
 672:	36 e1       	ldi	r19, 0x16	; 22
 674:	30 83       	st	Z, r19
 676:	31 97       	sbiw	r30, 0x01	; 1
 678:	37 e1       	ldi	r19, 0x17	; 23
 67a:	30 83       	st	Z, r19
 67c:	31 97       	sbiw	r30, 0x01	; 1
 67e:	38 e1       	ldi	r19, 0x18	; 24
 680:	30 83       	st	Z, r19
 682:	31 97       	sbiw	r30, 0x01	; 1
 684:	39 e1       	ldi	r19, 0x19	; 25
 686:	30 83       	st	Z, r19
 688:	31 97       	sbiw	r30, 0x01	; 1
 68a:	30 e2       	ldi	r19, 0x20	; 32
 68c:	30 83       	st	Z, r19
 68e:	31 97       	sbiw	r30, 0x01	; 1
 690:	31 e2       	ldi	r19, 0x21	; 33
 692:	30 83       	st	Z, r19
 694:	31 97       	sbiw	r30, 0x01	; 1
 696:	20 83       	st	Z, r18
 698:	31 97       	sbiw	r30, 0x01	; 1
 69a:	23 e2       	ldi	r18, 0x23	; 35
 69c:	20 83       	st	Z, r18
 69e:	31 97       	sbiw	r30, 0x01	; 1
 6a0:	40 83       	st	Z, r20
 6a2:	31 97       	sbiw	r30, 0x01	; 1
 6a4:	50 83       	st	Z, r21
 6a6:	31 97       	sbiw	r30, 0x01	; 1
 6a8:	26 e2       	ldi	r18, 0x26	; 38
 6aa:	20 83       	st	Z, r18
 6ac:	31 97       	sbiw	r30, 0x01	; 1
 6ae:	27 e2       	ldi	r18, 0x27	; 39
 6b0:	20 83       	st	Z, r18
 6b2:	31 97       	sbiw	r30, 0x01	; 1
 6b4:	28 e2       	ldi	r18, 0x28	; 40
 6b6:	20 83       	st	Z, r18
 6b8:	31 97       	sbiw	r30, 0x01	; 1
 6ba:	29 e2       	ldi	r18, 0x29	; 41
 6bc:	20 83       	st	Z, r18
 6be:	31 97       	sbiw	r30, 0x01	; 1
 6c0:	20 e3       	ldi	r18, 0x30	; 48
 6c2:	20 83       	st	Z, r18
 6c4:	31 97       	sbiw	r30, 0x01	; 1
 6c6:	21 e3       	ldi	r18, 0x31	; 49
 6c8:	20 83       	st	Z, r18
 6ca:	86 97       	sbiw	r24, 0x26	; 38
 6cc:	08 95       	ret

000006ce <xPortStartScheduler>:
 6ce:	1b bc       	out	0x2b, r1	; 43
 6d0:	89 ef       	ldi	r24, 0xF9	; 249
 6d2:	8a bd       	out	0x2a, r24	; 42
 6d4:	8b e0       	ldi	r24, 0x0B	; 11
 6d6:	8e bd       	out	0x2e, r24	; 46
 6d8:	89 b7       	in	r24, 0x39	; 57
 6da:	80 61       	ori	r24, 0x10	; 16
 6dc:	89 bf       	out	0x39, r24	; 57
 6de:	a0 91 b0 06 	lds	r26, 0x06B0	; 0x8006b0 <pxCurrentTCB>
 6e2:	b0 91 b1 06 	lds	r27, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
 6e6:	cd 91       	ld	r28, X+
 6e8:	cd bf       	out	0x3d, r28	; 61
 6ea:	dd 91       	ld	r29, X+
 6ec:	de bf       	out	0x3e, r29	; 62
 6ee:	ff 91       	pop	r31
 6f0:	ef 91       	pop	r30
 6f2:	df 91       	pop	r29
 6f4:	cf 91       	pop	r28
 6f6:	bf 91       	pop	r27
 6f8:	af 91       	pop	r26
 6fa:	9f 91       	pop	r25
 6fc:	8f 91       	pop	r24
 6fe:	7f 91       	pop	r23
 700:	6f 91       	pop	r22
 702:	5f 91       	pop	r21
 704:	4f 91       	pop	r20
 706:	3f 91       	pop	r19
 708:	2f 91       	pop	r18
 70a:	1f 91       	pop	r17
 70c:	0f 91       	pop	r16
 70e:	ff 90       	pop	r15
 710:	ef 90       	pop	r14
 712:	df 90       	pop	r13
 714:	cf 90       	pop	r12
 716:	bf 90       	pop	r11
 718:	af 90       	pop	r10
 71a:	9f 90       	pop	r9
 71c:	8f 90       	pop	r8
 71e:	7f 90       	pop	r7
 720:	6f 90       	pop	r6
 722:	5f 90       	pop	r5
 724:	4f 90       	pop	r4
 726:	3f 90       	pop	r3
 728:	2f 90       	pop	r2
 72a:	1f 90       	pop	r1
 72c:	0f 90       	pop	r0
 72e:	0f be       	out	0x3f, r0	; 63
 730:	0f 90       	pop	r0
 732:	08 95       	ret
 734:	81 e0       	ldi	r24, 0x01	; 1
 736:	08 95       	ret

00000738 <vPortYield>:
 738:	0f 92       	push	r0
 73a:	0f b6       	in	r0, 0x3f	; 63
 73c:	f8 94       	cli
 73e:	0f 92       	push	r0
 740:	1f 92       	push	r1
 742:	11 24       	eor	r1, r1
 744:	2f 92       	push	r2
 746:	3f 92       	push	r3
 748:	4f 92       	push	r4
 74a:	5f 92       	push	r5
 74c:	6f 92       	push	r6
 74e:	7f 92       	push	r7
 750:	8f 92       	push	r8
 752:	9f 92       	push	r9
 754:	af 92       	push	r10
 756:	bf 92       	push	r11
 758:	cf 92       	push	r12
 75a:	df 92       	push	r13
 75c:	ef 92       	push	r14
 75e:	ff 92       	push	r15
 760:	0f 93       	push	r16
 762:	1f 93       	push	r17
 764:	2f 93       	push	r18
 766:	3f 93       	push	r19
 768:	4f 93       	push	r20
 76a:	5f 93       	push	r21
 76c:	6f 93       	push	r22
 76e:	7f 93       	push	r23
 770:	8f 93       	push	r24
 772:	9f 93       	push	r25
 774:	af 93       	push	r26
 776:	bf 93       	push	r27
 778:	cf 93       	push	r28
 77a:	df 93       	push	r29
 77c:	ef 93       	push	r30
 77e:	ff 93       	push	r31
 780:	a0 91 b0 06 	lds	r26, 0x06B0	; 0x8006b0 <pxCurrentTCB>
 784:	b0 91 b1 06 	lds	r27, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
 788:	0d b6       	in	r0, 0x3d	; 61
 78a:	0d 92       	st	X+, r0
 78c:	0e b6       	in	r0, 0x3e	; 62
 78e:	0d 92       	st	X+, r0
 790:	0e 94 f3 06 	call	0xde6	; 0xde6 <vTaskSwitchContext>
 794:	a0 91 b0 06 	lds	r26, 0x06B0	; 0x8006b0 <pxCurrentTCB>
 798:	b0 91 b1 06 	lds	r27, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
 79c:	cd 91       	ld	r28, X+
 79e:	cd bf       	out	0x3d, r28	; 61
 7a0:	dd 91       	ld	r29, X+
 7a2:	de bf       	out	0x3e, r29	; 62
 7a4:	ff 91       	pop	r31
 7a6:	ef 91       	pop	r30
 7a8:	df 91       	pop	r29
 7aa:	cf 91       	pop	r28
 7ac:	bf 91       	pop	r27
 7ae:	af 91       	pop	r26
 7b0:	9f 91       	pop	r25
 7b2:	8f 91       	pop	r24
 7b4:	7f 91       	pop	r23
 7b6:	6f 91       	pop	r22
 7b8:	5f 91       	pop	r21
 7ba:	4f 91       	pop	r20
 7bc:	3f 91       	pop	r19
 7be:	2f 91       	pop	r18
 7c0:	1f 91       	pop	r17
 7c2:	0f 91       	pop	r16
 7c4:	ff 90       	pop	r15
 7c6:	ef 90       	pop	r14
 7c8:	df 90       	pop	r13
 7ca:	cf 90       	pop	r12
 7cc:	bf 90       	pop	r11
 7ce:	af 90       	pop	r10
 7d0:	9f 90       	pop	r9
 7d2:	8f 90       	pop	r8
 7d4:	7f 90       	pop	r7
 7d6:	6f 90       	pop	r6
 7d8:	5f 90       	pop	r5
 7da:	4f 90       	pop	r4
 7dc:	3f 90       	pop	r3
 7de:	2f 90       	pop	r2
 7e0:	1f 90       	pop	r1
 7e2:	0f 90       	pop	r0
 7e4:	0f be       	out	0x3f, r0	; 63
 7e6:	0f 90       	pop	r0
 7e8:	08 95       	ret

000007ea <__vector_7>:
	 * tick count.  We don't need to switch context, this can only be done by
	 * manual calls to taskYIELD();
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal ) );
	void TIMER1_COMPA_vect( void )
	{
 7ea:	1f 92       	push	r1
 7ec:	0f 92       	push	r0
 7ee:	0f b6       	in	r0, 0x3f	; 63
 7f0:	0f 92       	push	r0
 7f2:	11 24       	eor	r1, r1
 7f4:	2f 93       	push	r18
 7f6:	3f 93       	push	r19
 7f8:	4f 93       	push	r20
 7fa:	5f 93       	push	r21
 7fc:	6f 93       	push	r22
 7fe:	7f 93       	push	r23
 800:	8f 93       	push	r24
 802:	9f 93       	push	r25
 804:	af 93       	push	r26
 806:	bf 93       	push	r27
 808:	ef 93       	push	r30
 80a:	ff 93       	push	r31
		xTaskIncrementTick();
 80c:	0e 94 c8 05 	call	0xb90	; 0xb90 <xTaskIncrementTick>
	}
 810:	ff 91       	pop	r31
 812:	ef 91       	pop	r30
 814:	bf 91       	pop	r27
 816:	af 91       	pop	r26
 818:	9f 91       	pop	r25
 81a:	8f 91       	pop	r24
 81c:	7f 91       	pop	r23
 81e:	6f 91       	pop	r22
 820:	5f 91       	pop	r21
 822:	4f 91       	pop	r20
 824:	3f 91       	pop	r19
 826:	2f 91       	pop	r18
 828:	0f 90       	pop	r0
 82a:	0f be       	out	0x3f, r0	; 63
 82c:	0f 90       	pop	r0
 82e:	1f 90       	pop	r1
 830:	18 95       	reti

00000832 <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 832:	e0 91 78 06 	lds	r30, 0x0678	; 0x800678 <pxDelayedTaskList>
 836:	f0 91 79 06 	lds	r31, 0x0679	; 0x800679 <pxDelayedTaskList+0x1>
 83a:	80 81       	ld	r24, Z
 83c:	81 11       	cpse	r24, r1
 83e:	07 c0       	rjmp	.+14     	; 0x84e <prvResetNextTaskUnblockTime+0x1c>
 840:	8f ef       	ldi	r24, 0xFF	; 255
 842:	9f ef       	ldi	r25, 0xFF	; 255
 844:	90 93 5a 06 	sts	0x065A, r25	; 0x80065a <xNextTaskUnblockTime+0x1>
 848:	80 93 59 06 	sts	0x0659, r24	; 0x800659 <xNextTaskUnblockTime>
 84c:	08 95       	ret
 84e:	e0 91 78 06 	lds	r30, 0x0678	; 0x800678 <pxDelayedTaskList>
 852:	f0 91 79 06 	lds	r31, 0x0679	; 0x800679 <pxDelayedTaskList+0x1>
 856:	05 80       	ldd	r0, Z+5	; 0x05
 858:	f6 81       	ldd	r31, Z+6	; 0x06
 85a:	e0 2d       	mov	r30, r0
 85c:	06 80       	ldd	r0, Z+6	; 0x06
 85e:	f7 81       	ldd	r31, Z+7	; 0x07
 860:	e0 2d       	mov	r30, r0
 862:	82 81       	ldd	r24, Z+2	; 0x02
 864:	93 81       	ldd	r25, Z+3	; 0x03
 866:	90 93 5a 06 	sts	0x065A, r25	; 0x80065a <xNextTaskUnblockTime+0x1>
 86a:	80 93 59 06 	sts	0x0659, r24	; 0x800659 <xNextTaskUnblockTime>
 86e:	08 95       	ret

00000870 <prvIdleTask>:
 870:	0e 94 9c 03 	call	0x738	; 0x738 <vPortYield>
 874:	fd cf       	rjmp	.-6      	; 0x870 <prvIdleTask>

00000876 <prvAddCurrentTaskToDelayedList>:
 876:	ff 92       	push	r15
 878:	0f 93       	push	r16
 87a:	1f 93       	push	r17
 87c:	cf 93       	push	r28
 87e:	df 93       	push	r29
 880:	ec 01       	movw	r28, r24
 882:	f6 2e       	mov	r15, r22
 884:	00 91 61 06 	lds	r16, 0x0661	; 0x800661 <xTickCount>
 888:	10 91 62 06 	lds	r17, 0x0662	; 0x800662 <xTickCount+0x1>
 88c:	80 91 b0 06 	lds	r24, 0x06B0	; 0x8006b0 <pxCurrentTCB>
 890:	90 91 b1 06 	lds	r25, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
 894:	02 96       	adiw	r24, 0x02	; 2
 896:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <uxListRemove>
 89a:	cf 3f       	cpi	r28, 0xFF	; 255
 89c:	8f ef       	ldi	r24, 0xFF	; 255
 89e:	d8 07       	cpc	r29, r24
 8a0:	69 f4       	brne	.+26     	; 0x8bc <prvAddCurrentTaskToDelayedList+0x46>
 8a2:	ff 20       	and	r15, r15
 8a4:	59 f0       	breq	.+22     	; 0x8bc <prvAddCurrentTaskToDelayedList+0x46>
 8a6:	60 91 b0 06 	lds	r22, 0x06B0	; 0x8006b0 <pxCurrentTCB>
 8aa:	70 91 b1 06 	lds	r23, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
 8ae:	6e 5f       	subi	r22, 0xFE	; 254
 8b0:	7f 4f       	sbci	r23, 0xFF	; 255
 8b2:	84 e6       	ldi	r24, 0x64	; 100
 8b4:	96 e0       	ldi	r25, 0x06	; 6
 8b6:	0e 94 82 02 	call	0x504	; 0x504 <vListInsertEnd>
 8ba:	2f c0       	rjmp	.+94     	; 0x91a <prvAddCurrentTaskToDelayedList+0xa4>
 8bc:	c0 0f       	add	r28, r16
 8be:	d1 1f       	adc	r29, r17
 8c0:	e0 91 b0 06 	lds	r30, 0x06B0	; 0x8006b0 <pxCurrentTCB>
 8c4:	f0 91 b1 06 	lds	r31, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
 8c8:	d3 83       	std	Z+3, r29	; 0x03
 8ca:	c2 83       	std	Z+2, r28	; 0x02
 8cc:	c0 17       	cp	r28, r16
 8ce:	d1 07       	cpc	r29, r17
 8d0:	68 f4       	brcc	.+26     	; 0x8ec <prvAddCurrentTaskToDelayedList+0x76>
 8d2:	60 91 b0 06 	lds	r22, 0x06B0	; 0x8006b0 <pxCurrentTCB>
 8d6:	70 91 b1 06 	lds	r23, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
 8da:	80 91 76 06 	lds	r24, 0x0676	; 0x800676 <pxOverflowDelayedTaskList>
 8de:	90 91 77 06 	lds	r25, 0x0677	; 0x800677 <pxOverflowDelayedTaskList+0x1>
 8e2:	6e 5f       	subi	r22, 0xFE	; 254
 8e4:	7f 4f       	sbci	r23, 0xFF	; 255
 8e6:	0e 94 a3 02 	call	0x546	; 0x546 <vListInsert>
 8ea:	17 c0       	rjmp	.+46     	; 0x91a <prvAddCurrentTaskToDelayedList+0xa4>
 8ec:	60 91 b0 06 	lds	r22, 0x06B0	; 0x8006b0 <pxCurrentTCB>
 8f0:	70 91 b1 06 	lds	r23, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
 8f4:	80 91 78 06 	lds	r24, 0x0678	; 0x800678 <pxDelayedTaskList>
 8f8:	90 91 79 06 	lds	r25, 0x0679	; 0x800679 <pxDelayedTaskList+0x1>
 8fc:	6e 5f       	subi	r22, 0xFE	; 254
 8fe:	7f 4f       	sbci	r23, 0xFF	; 255
 900:	0e 94 a3 02 	call	0x546	; 0x546 <vListInsert>
 904:	80 91 59 06 	lds	r24, 0x0659	; 0x800659 <xNextTaskUnblockTime>
 908:	90 91 5a 06 	lds	r25, 0x065A	; 0x80065a <xNextTaskUnblockTime+0x1>
 90c:	c8 17       	cp	r28, r24
 90e:	d9 07       	cpc	r29, r25
 910:	20 f4       	brcc	.+8      	; 0x91a <prvAddCurrentTaskToDelayedList+0xa4>
 912:	d0 93 5a 06 	sts	0x065A, r29	; 0x80065a <xNextTaskUnblockTime+0x1>
 916:	c0 93 59 06 	sts	0x0659, r28	; 0x800659 <xNextTaskUnblockTime>
 91a:	df 91       	pop	r29
 91c:	cf 91       	pop	r28
 91e:	1f 91       	pop	r17
 920:	0f 91       	pop	r16
 922:	ff 90       	pop	r15
 924:	08 95       	ret

00000926 <xTaskCreate>:
 926:	4f 92       	push	r4
 928:	5f 92       	push	r5
 92a:	6f 92       	push	r6
 92c:	7f 92       	push	r7
 92e:	8f 92       	push	r8
 930:	9f 92       	push	r9
 932:	af 92       	push	r10
 934:	bf 92       	push	r11
 936:	cf 92       	push	r12
 938:	df 92       	push	r13
 93a:	ef 92       	push	r14
 93c:	ff 92       	push	r15
 93e:	0f 93       	push	r16
 940:	cf 93       	push	r28
 942:	df 93       	push	r29
 944:	4c 01       	movw	r8, r24
 946:	6b 01       	movw	r12, r22
 948:	5a 01       	movw	r10, r20
 94a:	29 01       	movw	r4, r18
 94c:	ca 01       	movw	r24, r20
 94e:	0e 94 3a 02 	call	0x474	; 0x474 <pvPortMalloc>
 952:	3c 01       	movw	r6, r24
 954:	89 2b       	or	r24, r25
 956:	09 f4       	brne	.+2      	; 0x95a <xTaskCreate+0x34>
 958:	da c0       	rjmp	.+436    	; 0xb0e <xTaskCreate+0x1e8>
 95a:	86 e2       	ldi	r24, 0x26	; 38
 95c:	90 e0       	ldi	r25, 0x00	; 0
 95e:	0e 94 3a 02 	call	0x474	; 0x474 <pvPortMalloc>
 962:	ec 01       	movw	r28, r24
 964:	89 2b       	or	r24, r25
 966:	59 f0       	breq	.+22     	; 0x97e <xTaskCreate+0x58>
 968:	78 8e       	std	Y+24, r7	; 0x18
 96a:	6f 8a       	std	Y+23, r6	; 0x17
 96c:	81 e0       	ldi	r24, 0x01	; 1
 96e:	a8 1a       	sub	r10, r24
 970:	b1 08       	sbc	r11, r1
 972:	a6 0c       	add	r10, r6
 974:	b7 1c       	adc	r11, r7
 976:	c1 14       	cp	r12, r1
 978:	d1 04       	cpc	r13, r1
 97a:	29 f4       	brne	.+10     	; 0x986 <xTaskCreate+0x60>
 97c:	20 c0       	rjmp	.+64     	; 0x9be <xTaskCreate+0x98>
 97e:	c3 01       	movw	r24, r6
 980:	0e 94 6f 02 	call	0x4de	; 0x4de <vPortFree>
 984:	c4 c0       	rjmp	.+392    	; 0xb0e <xTaskCreate+0x1e8>
 986:	d6 01       	movw	r26, r12
 988:	8c 91       	ld	r24, X
 98a:	89 8f       	std	Y+25, r24	; 0x19
 98c:	8c 91       	ld	r24, X
 98e:	88 23       	and	r24, r24
 990:	a1 f0       	breq	.+40     	; 0x9ba <xTaskCreate+0x94>
 992:	ae 01       	movw	r20, r28
 994:	46 5e       	subi	r20, 0xE6	; 230
 996:	5f 4f       	sbci	r21, 0xFF	; 255
 998:	f6 01       	movw	r30, r12
 99a:	31 96       	adiw	r30, 0x01	; 1
 99c:	b8 e0       	ldi	r27, 0x08	; 8
 99e:	cb 0e       	add	r12, r27
 9a0:	d1 1c       	adc	r13, r1
 9a2:	cf 01       	movw	r24, r30
 9a4:	21 91       	ld	r18, Z+
 9a6:	da 01       	movw	r26, r20
 9a8:	2d 93       	st	X+, r18
 9aa:	ad 01       	movw	r20, r26
 9ac:	dc 01       	movw	r26, r24
 9ae:	8c 91       	ld	r24, X
 9b0:	88 23       	and	r24, r24
 9b2:	19 f0       	breq	.+6      	; 0x9ba <xTaskCreate+0x94>
 9b4:	ec 15       	cp	r30, r12
 9b6:	fd 05       	cpc	r31, r13
 9b8:	a1 f7       	brne	.-24     	; 0x9a2 <xTaskCreate+0x7c>
 9ba:	18 a2       	std	Y+32, r1	; 0x20
 9bc:	01 c0       	rjmp	.+2      	; 0x9c0 <xTaskCreate+0x9a>
 9be:	19 8e       	std	Y+25, r1	; 0x19
 9c0:	04 30       	cpi	r16, 0x04	; 4
 9c2:	08 f0       	brcs	.+2      	; 0x9c6 <xTaskCreate+0xa0>
 9c4:	03 e0       	ldi	r16, 0x03	; 3
 9c6:	0e 8b       	std	Y+22, r16	; 0x16
 9c8:	6e 01       	movw	r12, r28
 9ca:	b2 e0       	ldi	r27, 0x02	; 2
 9cc:	cb 0e       	add	r12, r27
 9ce:	d1 1c       	adc	r13, r1
 9d0:	c6 01       	movw	r24, r12
 9d2:	0e 94 7e 02 	call	0x4fc	; 0x4fc <vListInitialiseItem>
 9d6:	ce 01       	movw	r24, r28
 9d8:	0c 96       	adiw	r24, 0x0c	; 12
 9da:	0e 94 7e 02 	call	0x4fc	; 0x4fc <vListInitialiseItem>
 9de:	d9 87       	std	Y+9, r29	; 0x09
 9e0:	c8 87       	std	Y+8, r28	; 0x08
 9e2:	84 e0       	ldi	r24, 0x04	; 4
 9e4:	90 e0       	ldi	r25, 0x00	; 0
 9e6:	80 1b       	sub	r24, r16
 9e8:	91 09       	sbc	r25, r1
 9ea:	9d 87       	std	Y+13, r25	; 0x0d
 9ec:	8c 87       	std	Y+12, r24	; 0x0c
 9ee:	db 8b       	std	Y+19, r29	; 0x13
 9f0:	ca 8b       	std	Y+18, r28	; 0x12
 9f2:	19 a2       	std	Y+33, r1	; 0x21
 9f4:	1a a2       	std	Y+34, r1	; 0x22
 9f6:	1b a2       	std	Y+35, r1	; 0x23
 9f8:	1c a2       	std	Y+36, r1	; 0x24
 9fa:	1d a2       	std	Y+37, r1	; 0x25
 9fc:	a2 01       	movw	r20, r4
 9fe:	b4 01       	movw	r22, r8
 a00:	c5 01       	movw	r24, r10
 a02:	0e 94 fb 02 	call	0x5f6	; 0x5f6 <pxPortInitialiseStack>
 a06:	99 83       	std	Y+1, r25	; 0x01
 a08:	88 83       	st	Y, r24
 a0a:	e1 14       	cp	r14, r1
 a0c:	f1 04       	cpc	r15, r1
 a0e:	19 f0       	breq	.+6      	; 0xa16 <xTaskCreate+0xf0>
 a10:	f7 01       	movw	r30, r14
 a12:	d1 83       	std	Z+1, r29	; 0x01
 a14:	c0 83       	st	Z, r28
 a16:	0f b6       	in	r0, 0x3f	; 63
 a18:	f8 94       	cli
 a1a:	0f 92       	push	r0
 a1c:	80 91 63 06 	lds	r24, 0x0663	; 0x800663 <uxCurrentNumberOfTasks>
 a20:	8f 5f       	subi	r24, 0xFF	; 255
 a22:	80 93 63 06 	sts	0x0663, r24	; 0x800663 <uxCurrentNumberOfTasks>
 a26:	80 91 b0 06 	lds	r24, 0x06B0	; 0x8006b0 <pxCurrentTCB>
 a2a:	90 91 b1 06 	lds	r25, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
 a2e:	89 2b       	or	r24, r25
 a30:	a9 f5       	brne	.+106    	; 0xa9c <xTaskCreate+0x176>
 a32:	d0 93 b1 06 	sts	0x06B1, r29	; 0x8006b1 <pxCurrentTCB+0x1>
 a36:	c0 93 b0 06 	sts	0x06B0, r28	; 0x8006b0 <pxCurrentTCB>
 a3a:	80 91 63 06 	lds	r24, 0x0663	; 0x800663 <uxCurrentNumberOfTasks>
 a3e:	81 30       	cpi	r24, 0x01	; 1
 a40:	e9 f5       	brne	.+122    	; 0xabc <xTaskCreate+0x196>
 a42:	8c e8       	ldi	r24, 0x8C	; 140
 a44:	96 e0       	ldi	r25, 0x06	; 6
 a46:	0e 94 70 02 	call	0x4e0	; 0x4e0 <vListInitialise>
 a4a:	85 e9       	ldi	r24, 0x95	; 149
 a4c:	96 e0       	ldi	r25, 0x06	; 6
 a4e:	0e 94 70 02 	call	0x4e0	; 0x4e0 <vListInitialise>
 a52:	8e e9       	ldi	r24, 0x9E	; 158
 a54:	96 e0       	ldi	r25, 0x06	; 6
 a56:	0e 94 70 02 	call	0x4e0	; 0x4e0 <vListInitialise>
 a5a:	87 ea       	ldi	r24, 0xA7	; 167
 a5c:	96 e0       	ldi	r25, 0x06	; 6
 a5e:	0e 94 70 02 	call	0x4e0	; 0x4e0 <vListInitialise>
 a62:	83 e8       	ldi	r24, 0x83	; 131
 a64:	96 e0       	ldi	r25, 0x06	; 6
 a66:	0e 94 70 02 	call	0x4e0	; 0x4e0 <vListInitialise>
 a6a:	8a e7       	ldi	r24, 0x7A	; 122
 a6c:	96 e0       	ldi	r25, 0x06	; 6
 a6e:	0e 94 70 02 	call	0x4e0	; 0x4e0 <vListInitialise>
 a72:	8d e6       	ldi	r24, 0x6D	; 109
 a74:	96 e0       	ldi	r25, 0x06	; 6
 a76:	0e 94 70 02 	call	0x4e0	; 0x4e0 <vListInitialise>
 a7a:	84 e6       	ldi	r24, 0x64	; 100
 a7c:	96 e0       	ldi	r25, 0x06	; 6
 a7e:	0e 94 70 02 	call	0x4e0	; 0x4e0 <vListInitialise>
 a82:	83 e8       	ldi	r24, 0x83	; 131
 a84:	96 e0       	ldi	r25, 0x06	; 6
 a86:	90 93 79 06 	sts	0x0679, r25	; 0x800679 <pxDelayedTaskList+0x1>
 a8a:	80 93 78 06 	sts	0x0678, r24	; 0x800678 <pxDelayedTaskList>
 a8e:	8a e7       	ldi	r24, 0x7A	; 122
 a90:	96 e0       	ldi	r25, 0x06	; 6
 a92:	90 93 77 06 	sts	0x0677, r25	; 0x800677 <pxOverflowDelayedTaskList+0x1>
 a96:	80 93 76 06 	sts	0x0676, r24	; 0x800676 <pxOverflowDelayedTaskList>
 a9a:	10 c0       	rjmp	.+32     	; 0xabc <xTaskCreate+0x196>
 a9c:	80 91 5f 06 	lds	r24, 0x065F	; 0x80065f <xSchedulerRunning>
 aa0:	81 11       	cpse	r24, r1
 aa2:	0c c0       	rjmp	.+24     	; 0xabc <xTaskCreate+0x196>
 aa4:	e0 91 b0 06 	lds	r30, 0x06B0	; 0x8006b0 <pxCurrentTCB>
 aa8:	f0 91 b1 06 	lds	r31, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
 aac:	96 89       	ldd	r25, Z+22	; 0x16
 aae:	8e 89       	ldd	r24, Y+22	; 0x16
 ab0:	89 17       	cp	r24, r25
 ab2:	20 f0       	brcs	.+8      	; 0xabc <xTaskCreate+0x196>
 ab4:	d0 93 b1 06 	sts	0x06B1, r29	; 0x8006b1 <pxCurrentTCB+0x1>
 ab8:	c0 93 b0 06 	sts	0x06B0, r28	; 0x8006b0 <pxCurrentTCB>
 abc:	80 91 5b 06 	lds	r24, 0x065B	; 0x80065b <uxTaskNumber>
 ac0:	8f 5f       	subi	r24, 0xFF	; 255
 ac2:	80 93 5b 06 	sts	0x065B, r24	; 0x80065b <uxTaskNumber>
 ac6:	8e 89       	ldd	r24, Y+22	; 0x16
 ac8:	90 91 60 06 	lds	r25, 0x0660	; 0x800660 <uxTopReadyPriority>
 acc:	98 17       	cp	r25, r24
 ace:	10 f4       	brcc	.+4      	; 0xad4 <xTaskCreate+0x1ae>
 ad0:	80 93 60 06 	sts	0x0660, r24	; 0x800660 <uxTopReadyPriority>
 ad4:	90 e0       	ldi	r25, 0x00	; 0
 ad6:	9c 01       	movw	r18, r24
 ad8:	22 0f       	add	r18, r18
 ada:	33 1f       	adc	r19, r19
 adc:	22 0f       	add	r18, r18
 ade:	33 1f       	adc	r19, r19
 ae0:	22 0f       	add	r18, r18
 ae2:	33 1f       	adc	r19, r19
 ae4:	82 0f       	add	r24, r18
 ae6:	93 1f       	adc	r25, r19
 ae8:	b6 01       	movw	r22, r12
 aea:	84 57       	subi	r24, 0x74	; 116
 aec:	99 4f       	sbci	r25, 0xF9	; 249
 aee:	0e 94 82 02 	call	0x504	; 0x504 <vListInsertEnd>
 af2:	0f 90       	pop	r0
 af4:	0f be       	out	0x3f, r0	; 63
 af6:	80 91 5f 06 	lds	r24, 0x065F	; 0x80065f <xSchedulerRunning>
 afa:	88 23       	and	r24, r24
 afc:	31 f0       	breq	.+12     	; 0xb0a <xTaskCreate+0x1e4>
 afe:	80 91 b0 06 	lds	r24, 0x06B0	; 0x8006b0 <pxCurrentTCB>
 b02:	90 91 b1 06 	lds	r25, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
 b06:	81 e0       	ldi	r24, 0x01	; 1
 b08:	03 c0       	rjmp	.+6      	; 0xb10 <xTaskCreate+0x1ea>
 b0a:	81 e0       	ldi	r24, 0x01	; 1
 b0c:	01 c0       	rjmp	.+2      	; 0xb10 <xTaskCreate+0x1ea>
 b0e:	8f ef       	ldi	r24, 0xFF	; 255
 b10:	df 91       	pop	r29
 b12:	cf 91       	pop	r28
 b14:	0f 91       	pop	r16
 b16:	ff 90       	pop	r15
 b18:	ef 90       	pop	r14
 b1a:	df 90       	pop	r13
 b1c:	cf 90       	pop	r12
 b1e:	bf 90       	pop	r11
 b20:	af 90       	pop	r10
 b22:	9f 90       	pop	r9
 b24:	8f 90       	pop	r8
 b26:	7f 90       	pop	r7
 b28:	6f 90       	pop	r6
 b2a:	5f 90       	pop	r5
 b2c:	4f 90       	pop	r4
 b2e:	08 95       	ret

00000b30 <vTaskStartScheduler>:
 b30:	ef 92       	push	r14
 b32:	ff 92       	push	r15
 b34:	0f 93       	push	r16
 b36:	0f 2e       	mov	r0, r31
 b38:	f7 e5       	ldi	r31, 0x57	; 87
 b3a:	ef 2e       	mov	r14, r31
 b3c:	f6 e0       	ldi	r31, 0x06	; 6
 b3e:	ff 2e       	mov	r15, r31
 b40:	f0 2d       	mov	r31, r0
 b42:	00 e0       	ldi	r16, 0x00	; 0
 b44:	20 e0       	ldi	r18, 0x00	; 0
 b46:	30 e0       	ldi	r19, 0x00	; 0
 b48:	45 e5       	ldi	r20, 0x55	; 85
 b4a:	50 e0       	ldi	r21, 0x00	; 0
 b4c:	69 e6       	ldi	r22, 0x69	; 105
 b4e:	70 e0       	ldi	r23, 0x00	; 0
 b50:	88 e3       	ldi	r24, 0x38	; 56
 b52:	94 e0       	ldi	r25, 0x04	; 4
 b54:	0e 94 93 04 	call	0x926	; 0x926 <xTaskCreate>
 b58:	81 30       	cpi	r24, 0x01	; 1
 b5a:	81 f4       	brne	.+32     	; 0xb7c <vTaskStartScheduler+0x4c>
 b5c:	f8 94       	cli
 b5e:	8f ef       	ldi	r24, 0xFF	; 255
 b60:	9f ef       	ldi	r25, 0xFF	; 255
 b62:	90 93 5a 06 	sts	0x065A, r25	; 0x80065a <xNextTaskUnblockTime+0x1>
 b66:	80 93 59 06 	sts	0x0659, r24	; 0x800659 <xNextTaskUnblockTime>
 b6a:	81 e0       	ldi	r24, 0x01	; 1
 b6c:	80 93 5f 06 	sts	0x065F, r24	; 0x80065f <xSchedulerRunning>
 b70:	10 92 62 06 	sts	0x0662, r1	; 0x800662 <xTickCount+0x1>
 b74:	10 92 61 06 	sts	0x0661, r1	; 0x800661 <xTickCount>
 b78:	0e 94 67 03 	call	0x6ce	; 0x6ce <xPortStartScheduler>
 b7c:	0f 91       	pop	r16
 b7e:	ff 90       	pop	r15
 b80:	ef 90       	pop	r14
 b82:	08 95       	ret

00000b84 <vTaskSuspendAll>:
 b84:	80 91 56 06 	lds	r24, 0x0656	; 0x800656 <uxSchedulerSuspended>
 b88:	8f 5f       	subi	r24, 0xFF	; 255
 b8a:	80 93 56 06 	sts	0x0656, r24	; 0x800656 <uxSchedulerSuspended>
 b8e:	08 95       	ret

00000b90 <xTaskIncrementTick>:
 b90:	ef 92       	push	r14
 b92:	ff 92       	push	r15
 b94:	0f 93       	push	r16
 b96:	1f 93       	push	r17
 b98:	cf 93       	push	r28
 b9a:	df 93       	push	r29
 b9c:	80 91 56 06 	lds	r24, 0x0656	; 0x800656 <uxSchedulerSuspended>
 ba0:	81 11       	cpse	r24, r1
 ba2:	89 c0       	rjmp	.+274    	; 0xcb6 <xTaskIncrementTick+0x126>
 ba4:	e0 90 61 06 	lds	r14, 0x0661	; 0x800661 <xTickCount>
 ba8:	f0 90 62 06 	lds	r15, 0x0662	; 0x800662 <xTickCount+0x1>
 bac:	8f ef       	ldi	r24, 0xFF	; 255
 bae:	e8 1a       	sub	r14, r24
 bb0:	f8 0a       	sbc	r15, r24
 bb2:	f0 92 62 06 	sts	0x0662, r15	; 0x800662 <xTickCount+0x1>
 bb6:	e0 92 61 06 	sts	0x0661, r14	; 0x800661 <xTickCount>
 bba:	e1 14       	cp	r14, r1
 bbc:	f1 04       	cpc	r15, r1
 bbe:	b9 f4       	brne	.+46     	; 0xbee <xTaskIncrementTick+0x5e>
 bc0:	80 91 78 06 	lds	r24, 0x0678	; 0x800678 <pxDelayedTaskList>
 bc4:	90 91 79 06 	lds	r25, 0x0679	; 0x800679 <pxDelayedTaskList+0x1>
 bc8:	20 91 76 06 	lds	r18, 0x0676	; 0x800676 <pxOverflowDelayedTaskList>
 bcc:	30 91 77 06 	lds	r19, 0x0677	; 0x800677 <pxOverflowDelayedTaskList+0x1>
 bd0:	30 93 79 06 	sts	0x0679, r19	; 0x800679 <pxDelayedTaskList+0x1>
 bd4:	20 93 78 06 	sts	0x0678, r18	; 0x800678 <pxDelayedTaskList>
 bd8:	90 93 77 06 	sts	0x0677, r25	; 0x800677 <pxOverflowDelayedTaskList+0x1>
 bdc:	80 93 76 06 	sts	0x0676, r24	; 0x800676 <pxOverflowDelayedTaskList>
 be0:	80 91 5c 06 	lds	r24, 0x065C	; 0x80065c <xNumOfOverflows>
 be4:	8f 5f       	subi	r24, 0xFF	; 255
 be6:	80 93 5c 06 	sts	0x065C, r24	; 0x80065c <xNumOfOverflows>
 bea:	0e 94 19 04 	call	0x832	; 0x832 <prvResetNextTaskUnblockTime>
 bee:	80 91 59 06 	lds	r24, 0x0659	; 0x800659 <xNextTaskUnblockTime>
 bf2:	90 91 5a 06 	lds	r25, 0x065A	; 0x80065a <xNextTaskUnblockTime+0x1>
 bf6:	e8 16       	cp	r14, r24
 bf8:	f9 06       	cpc	r15, r25
 bfa:	08 f4       	brcc	.+2      	; 0xbfe <xTaskIncrementTick+0x6e>
 bfc:	61 c0       	rjmp	.+194    	; 0xcc0 <xTaskIncrementTick+0x130>
 bfe:	e0 91 78 06 	lds	r30, 0x0678	; 0x800678 <pxDelayedTaskList>
 c02:	f0 91 79 06 	lds	r31, 0x0679	; 0x800679 <pxDelayedTaskList+0x1>
 c06:	80 81       	ld	r24, Z
 c08:	88 23       	and	r24, r24
 c0a:	79 f0       	breq	.+30     	; 0xc2a <xTaskIncrementTick+0x9a>
 c0c:	e0 91 78 06 	lds	r30, 0x0678	; 0x800678 <pxDelayedTaskList>
 c10:	f0 91 79 06 	lds	r31, 0x0679	; 0x800679 <pxDelayedTaskList+0x1>
 c14:	05 80       	ldd	r0, Z+5	; 0x05
 c16:	f6 81       	ldd	r31, Z+6	; 0x06
 c18:	e0 2d       	mov	r30, r0
 c1a:	c6 81       	ldd	r28, Z+6	; 0x06
 c1c:	d7 81       	ldd	r29, Z+7	; 0x07
 c1e:	8a 81       	ldd	r24, Y+2	; 0x02
 c20:	9b 81       	ldd	r25, Y+3	; 0x03
 c22:	e8 16       	cp	r14, r24
 c24:	f9 06       	cpc	r15, r25
 c26:	d8 f4       	brcc	.+54     	; 0xc5e <xTaskIncrementTick+0xce>
 c28:	15 c0       	rjmp	.+42     	; 0xc54 <xTaskIncrementTick+0xc4>
 c2a:	8f ef       	ldi	r24, 0xFF	; 255
 c2c:	9f ef       	ldi	r25, 0xFF	; 255
 c2e:	90 93 5a 06 	sts	0x065A, r25	; 0x80065a <xNextTaskUnblockTime+0x1>
 c32:	80 93 59 06 	sts	0x0659, r24	; 0x800659 <xNextTaskUnblockTime>
 c36:	44 c0       	rjmp	.+136    	; 0xcc0 <xTaskIncrementTick+0x130>
 c38:	e0 91 78 06 	lds	r30, 0x0678	; 0x800678 <pxDelayedTaskList>
 c3c:	f0 91 79 06 	lds	r31, 0x0679	; 0x800679 <pxDelayedTaskList+0x1>
 c40:	05 80       	ldd	r0, Z+5	; 0x05
 c42:	f6 81       	ldd	r31, Z+6	; 0x06
 c44:	e0 2d       	mov	r30, r0
 c46:	c6 81       	ldd	r28, Z+6	; 0x06
 c48:	d7 81       	ldd	r29, Z+7	; 0x07
 c4a:	8a 81       	ldd	r24, Y+2	; 0x02
 c4c:	9b 81       	ldd	r25, Y+3	; 0x03
 c4e:	e8 16       	cp	r14, r24
 c50:	f9 06       	cpc	r15, r25
 c52:	28 f4       	brcc	.+10     	; 0xc5e <xTaskIncrementTick+0xce>
 c54:	90 93 5a 06 	sts	0x065A, r25	; 0x80065a <xNextTaskUnblockTime+0x1>
 c58:	80 93 59 06 	sts	0x0659, r24	; 0x800659 <xNextTaskUnblockTime>
 c5c:	31 c0       	rjmp	.+98     	; 0xcc0 <xTaskIncrementTick+0x130>
 c5e:	8e 01       	movw	r16, r28
 c60:	0e 5f       	subi	r16, 0xFE	; 254
 c62:	1f 4f       	sbci	r17, 0xFF	; 255
 c64:	c8 01       	movw	r24, r16
 c66:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <uxListRemove>
 c6a:	8c 89       	ldd	r24, Y+20	; 0x14
 c6c:	9d 89       	ldd	r25, Y+21	; 0x15
 c6e:	89 2b       	or	r24, r25
 c70:	21 f0       	breq	.+8      	; 0xc7a <xTaskIncrementTick+0xea>
 c72:	ce 01       	movw	r24, r28
 c74:	0c 96       	adiw	r24, 0x0c	; 12
 c76:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <uxListRemove>
 c7a:	8e 89       	ldd	r24, Y+22	; 0x16
 c7c:	90 91 60 06 	lds	r25, 0x0660	; 0x800660 <uxTopReadyPriority>
 c80:	98 17       	cp	r25, r24
 c82:	10 f4       	brcc	.+4      	; 0xc88 <xTaskIncrementTick+0xf8>
 c84:	80 93 60 06 	sts	0x0660, r24	; 0x800660 <uxTopReadyPriority>
 c88:	90 e0       	ldi	r25, 0x00	; 0
 c8a:	9c 01       	movw	r18, r24
 c8c:	22 0f       	add	r18, r18
 c8e:	33 1f       	adc	r19, r19
 c90:	22 0f       	add	r18, r18
 c92:	33 1f       	adc	r19, r19
 c94:	22 0f       	add	r18, r18
 c96:	33 1f       	adc	r19, r19
 c98:	82 0f       	add	r24, r18
 c9a:	93 1f       	adc	r25, r19
 c9c:	b8 01       	movw	r22, r16
 c9e:	84 57       	subi	r24, 0x74	; 116
 ca0:	99 4f       	sbci	r25, 0xF9	; 249
 ca2:	0e 94 82 02 	call	0x504	; 0x504 <vListInsertEnd>
 ca6:	e0 91 78 06 	lds	r30, 0x0678	; 0x800678 <pxDelayedTaskList>
 caa:	f0 91 79 06 	lds	r31, 0x0679	; 0x800679 <pxDelayedTaskList+0x1>
 cae:	80 81       	ld	r24, Z
 cb0:	81 11       	cpse	r24, r1
 cb2:	c2 cf       	rjmp	.-124    	; 0xc38 <xTaskIncrementTick+0xa8>
 cb4:	ba cf       	rjmp	.-140    	; 0xc2a <xTaskIncrementTick+0x9a>
 cb6:	80 91 5e 06 	lds	r24, 0x065E	; 0x80065e <uxPendedTicks>
 cba:	8f 5f       	subi	r24, 0xFF	; 255
 cbc:	80 93 5e 06 	sts	0x065E, r24	; 0x80065e <uxPendedTicks>
 cc0:	80 e0       	ldi	r24, 0x00	; 0
 cc2:	df 91       	pop	r29
 cc4:	cf 91       	pop	r28
 cc6:	1f 91       	pop	r17
 cc8:	0f 91       	pop	r16
 cca:	ff 90       	pop	r15
 ccc:	ef 90       	pop	r14
 cce:	08 95       	ret

00000cd0 <xTaskResumeAll>:
 cd0:	df 92       	push	r13
 cd2:	ef 92       	push	r14
 cd4:	ff 92       	push	r15
 cd6:	0f 93       	push	r16
 cd8:	1f 93       	push	r17
 cda:	cf 93       	push	r28
 cdc:	df 93       	push	r29
 cde:	0f b6       	in	r0, 0x3f	; 63
 ce0:	f8 94       	cli
 ce2:	0f 92       	push	r0
 ce4:	80 91 56 06 	lds	r24, 0x0656	; 0x800656 <uxSchedulerSuspended>
 ce8:	81 50       	subi	r24, 0x01	; 1
 cea:	80 93 56 06 	sts	0x0656, r24	; 0x800656 <uxSchedulerSuspended>
 cee:	80 91 56 06 	lds	r24, 0x0656	; 0x800656 <uxSchedulerSuspended>
 cf2:	81 11       	cpse	r24, r1
 cf4:	59 c0       	rjmp	.+178    	; 0xda8 <xTaskResumeAll+0xd8>
 cf6:	80 91 63 06 	lds	r24, 0x0663	; 0x800663 <uxCurrentNumberOfTasks>
 cfa:	81 11       	cpse	r24, r1
 cfc:	33 c0       	rjmp	.+102    	; 0xd64 <xTaskResumeAll+0x94>
 cfe:	54 c0       	rjmp	.+168    	; 0xda8 <xTaskResumeAll+0xd8>
 d00:	d7 01       	movw	r26, r14
 d02:	15 96       	adiw	r26, 0x05	; 5
 d04:	ed 91       	ld	r30, X+
 d06:	fc 91       	ld	r31, X
 d08:	16 97       	sbiw	r26, 0x06	; 6
 d0a:	c6 81       	ldd	r28, Z+6	; 0x06
 d0c:	d7 81       	ldd	r29, Z+7	; 0x07
 d0e:	ce 01       	movw	r24, r28
 d10:	0c 96       	adiw	r24, 0x0c	; 12
 d12:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <uxListRemove>
 d16:	8e 01       	movw	r16, r28
 d18:	0e 5f       	subi	r16, 0xFE	; 254
 d1a:	1f 4f       	sbci	r17, 0xFF	; 255
 d1c:	c8 01       	movw	r24, r16
 d1e:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <uxListRemove>
 d22:	8e 89       	ldd	r24, Y+22	; 0x16
 d24:	90 91 60 06 	lds	r25, 0x0660	; 0x800660 <uxTopReadyPriority>
 d28:	98 17       	cp	r25, r24
 d2a:	10 f4       	brcc	.+4      	; 0xd30 <xTaskResumeAll+0x60>
 d2c:	80 93 60 06 	sts	0x0660, r24	; 0x800660 <uxTopReadyPriority>
 d30:	90 e0       	ldi	r25, 0x00	; 0
 d32:	9c 01       	movw	r18, r24
 d34:	22 0f       	add	r18, r18
 d36:	33 1f       	adc	r19, r19
 d38:	22 0f       	add	r18, r18
 d3a:	33 1f       	adc	r19, r19
 d3c:	22 0f       	add	r18, r18
 d3e:	33 1f       	adc	r19, r19
 d40:	82 0f       	add	r24, r18
 d42:	93 1f       	adc	r25, r19
 d44:	b8 01       	movw	r22, r16
 d46:	84 57       	subi	r24, 0x74	; 116
 d48:	99 4f       	sbci	r25, 0xF9	; 249
 d4a:	0e 94 82 02 	call	0x504	; 0x504 <vListInsertEnd>
 d4e:	e0 91 b0 06 	lds	r30, 0x06B0	; 0x8006b0 <pxCurrentTCB>
 d52:	f0 91 b1 06 	lds	r31, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
 d56:	9e 89       	ldd	r25, Y+22	; 0x16
 d58:	86 89       	ldd	r24, Z+22	; 0x16
 d5a:	98 17       	cp	r25, r24
 d5c:	68 f0       	brcs	.+26     	; 0xd78 <xTaskResumeAll+0xa8>
 d5e:	d0 92 5d 06 	sts	0x065D, r13	; 0x80065d <xYieldPending>
 d62:	0a c0       	rjmp	.+20     	; 0xd78 <xTaskResumeAll+0xa8>
 d64:	c0 e0       	ldi	r28, 0x00	; 0
 d66:	d0 e0       	ldi	r29, 0x00	; 0
 d68:	0f 2e       	mov	r0, r31
 d6a:	fd e6       	ldi	r31, 0x6D	; 109
 d6c:	ef 2e       	mov	r14, r31
 d6e:	f6 e0       	ldi	r31, 0x06	; 6
 d70:	ff 2e       	mov	r15, r31
 d72:	f0 2d       	mov	r31, r0
 d74:	dd 24       	eor	r13, r13
 d76:	d3 94       	inc	r13
 d78:	f7 01       	movw	r30, r14
 d7a:	80 81       	ld	r24, Z
 d7c:	81 11       	cpse	r24, r1
 d7e:	c0 cf       	rjmp	.-128    	; 0xd00 <xTaskResumeAll+0x30>
 d80:	cd 2b       	or	r28, r29
 d82:	11 f0       	breq	.+4      	; 0xd88 <xTaskResumeAll+0xb8>
 d84:	0e 94 19 04 	call	0x832	; 0x832 <prvResetNextTaskUnblockTime>
 d88:	c0 91 5e 06 	lds	r28, 0x065E	; 0x80065e <uxPendedTicks>
 d8c:	cc 23       	and	r28, r28
 d8e:	51 f0       	breq	.+20     	; 0xda4 <xTaskResumeAll+0xd4>
 d90:	d1 e0       	ldi	r29, 0x01	; 1
 d92:	0e 94 c8 05 	call	0xb90	; 0xb90 <xTaskIncrementTick>
 d96:	81 11       	cpse	r24, r1
 d98:	d0 93 5d 06 	sts	0x065D, r29	; 0x80065d <xYieldPending>
 d9c:	c1 50       	subi	r28, 0x01	; 1
 d9e:	c9 f7       	brne	.-14     	; 0xd92 <xTaskResumeAll+0xc2>
 da0:	10 92 5e 06 	sts	0x065E, r1	; 0x80065e <uxPendedTicks>
 da4:	80 91 5d 06 	lds	r24, 0x065D	; 0x80065d <xYieldPending>
 da8:	0f 90       	pop	r0
 daa:	0f be       	out	0x3f, r0	; 63
 dac:	80 e0       	ldi	r24, 0x00	; 0
 dae:	df 91       	pop	r29
 db0:	cf 91       	pop	r28
 db2:	1f 91       	pop	r17
 db4:	0f 91       	pop	r16
 db6:	ff 90       	pop	r15
 db8:	ef 90       	pop	r14
 dba:	df 90       	pop	r13
 dbc:	08 95       	ret

00000dbe <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 dbe:	cf 93       	push	r28
 dc0:	df 93       	push	r29
 dc2:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 dc4:	89 2b       	or	r24, r25
 dc6:	51 f0       	breq	.+20     	; 0xddc <vTaskDelay+0x1e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
 dc8:	0e 94 c2 05 	call	0xb84	; 0xb84 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 dcc:	60 e0       	ldi	r22, 0x00	; 0
 dce:	ce 01       	movw	r24, r28
 dd0:	0e 94 3b 04 	call	0x876	; 0x876 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 dd4:	0e 94 68 06 	call	0xcd0	; 0xcd0 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 dd8:	81 11       	cpse	r24, r1
 dda:	02 c0       	rjmp	.+4      	; 0xde0 <vTaskDelay+0x22>
		{
			portYIELD_WITHIN_API();
 ddc:	0e 94 9c 03 	call	0x738	; 0x738 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 de0:	df 91       	pop	r29
 de2:	cf 91       	pop	r28
 de4:	08 95       	ret

00000de6 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 de6:	80 91 56 06 	lds	r24, 0x0656	; 0x800656 <uxSchedulerSuspended>
 dea:	88 23       	and	r24, r24
 dec:	21 f0       	breq	.+8      	; 0xdf6 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 dee:	81 e0       	ldi	r24, 0x01	; 1
 df0:	80 93 5d 06 	sts	0x065D, r24	; 0x80065d <xYieldPending>
 df4:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
 df6:	10 92 5d 06 	sts	0x065D, r1	; 0x80065d <xYieldPending>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 dfa:	20 91 60 06 	lds	r18, 0x0660	; 0x800660 <uxTopReadyPriority>
 dfe:	82 2f       	mov	r24, r18
 e00:	90 e0       	ldi	r25, 0x00	; 0
 e02:	fc 01       	movw	r30, r24
 e04:	ee 0f       	add	r30, r30
 e06:	ff 1f       	adc	r31, r31
 e08:	ee 0f       	add	r30, r30
 e0a:	ff 1f       	adc	r31, r31
 e0c:	ee 0f       	add	r30, r30
 e0e:	ff 1f       	adc	r31, r31
 e10:	e8 0f       	add	r30, r24
 e12:	f9 1f       	adc	r31, r25
 e14:	e4 57       	subi	r30, 0x74	; 116
 e16:	f9 4f       	sbci	r31, 0xF9	; 249
 e18:	30 81       	ld	r19, Z
 e1a:	31 11       	cpse	r19, r1
 e1c:	11 c0       	rjmp	.+34     	; 0xe40 <vTaskSwitchContext+0x5a>
 e1e:	21 50       	subi	r18, 0x01	; 1
 e20:	82 2f       	mov	r24, r18
 e22:	90 e0       	ldi	r25, 0x00	; 0
 e24:	fc 01       	movw	r30, r24
 e26:	ee 0f       	add	r30, r30
 e28:	ff 1f       	adc	r31, r31
 e2a:	ee 0f       	add	r30, r30
 e2c:	ff 1f       	adc	r31, r31
 e2e:	ee 0f       	add	r30, r30
 e30:	ff 1f       	adc	r31, r31
 e32:	e8 0f       	add	r30, r24
 e34:	f9 1f       	adc	r31, r25
 e36:	e4 57       	subi	r30, 0x74	; 116
 e38:	f9 4f       	sbci	r31, 0xF9	; 249
 e3a:	30 81       	ld	r19, Z
 e3c:	33 23       	and	r19, r19
 e3e:	79 f3       	breq	.-34     	; 0xe1e <vTaskSwitchContext+0x38>
 e40:	ac 01       	movw	r20, r24
 e42:	44 0f       	add	r20, r20
 e44:	55 1f       	adc	r21, r21
 e46:	44 0f       	add	r20, r20
 e48:	55 1f       	adc	r21, r21
 e4a:	44 0f       	add	r20, r20
 e4c:	55 1f       	adc	r21, r21
 e4e:	48 0f       	add	r20, r24
 e50:	59 1f       	adc	r21, r25
 e52:	da 01       	movw	r26, r20
 e54:	a4 57       	subi	r26, 0x74	; 116
 e56:	b9 4f       	sbci	r27, 0xF9	; 249
 e58:	11 96       	adiw	r26, 0x01	; 1
 e5a:	ed 91       	ld	r30, X+
 e5c:	fc 91       	ld	r31, X
 e5e:	12 97       	sbiw	r26, 0x02	; 2
 e60:	02 80       	ldd	r0, Z+2	; 0x02
 e62:	f3 81       	ldd	r31, Z+3	; 0x03
 e64:	e0 2d       	mov	r30, r0
 e66:	12 96       	adiw	r26, 0x02	; 2
 e68:	fc 93       	st	X, r31
 e6a:	ee 93       	st	-X, r30
 e6c:	11 97       	sbiw	r26, 0x01	; 1
 e6e:	41 57       	subi	r20, 0x71	; 113
 e70:	59 4f       	sbci	r21, 0xF9	; 249
 e72:	e4 17       	cp	r30, r20
 e74:	f5 07       	cpc	r31, r21
 e76:	29 f4       	brne	.+10     	; 0xe82 <vTaskSwitchContext+0x9c>
 e78:	42 81       	ldd	r20, Z+2	; 0x02
 e7a:	53 81       	ldd	r21, Z+3	; 0x03
 e7c:	fd 01       	movw	r30, r26
 e7e:	52 83       	std	Z+2, r21	; 0x02
 e80:	41 83       	std	Z+1, r20	; 0x01
 e82:	fc 01       	movw	r30, r24
 e84:	ee 0f       	add	r30, r30
 e86:	ff 1f       	adc	r31, r31
 e88:	ee 0f       	add	r30, r30
 e8a:	ff 1f       	adc	r31, r31
 e8c:	ee 0f       	add	r30, r30
 e8e:	ff 1f       	adc	r31, r31
 e90:	8e 0f       	add	r24, r30
 e92:	9f 1f       	adc	r25, r31
 e94:	fc 01       	movw	r30, r24
 e96:	e4 57       	subi	r30, 0x74	; 116
 e98:	f9 4f       	sbci	r31, 0xF9	; 249
 e9a:	01 80       	ldd	r0, Z+1	; 0x01
 e9c:	f2 81       	ldd	r31, Z+2	; 0x02
 e9e:	e0 2d       	mov	r30, r0
 ea0:	86 81       	ldd	r24, Z+6	; 0x06
 ea2:	97 81       	ldd	r25, Z+7	; 0x07
 ea4:	90 93 b1 06 	sts	0x06B1, r25	; 0x8006b1 <pxCurrentTCB+0x1>
 ea8:	80 93 b0 06 	sts	0x06B0, r24	; 0x8006b0 <pxCurrentTCB>
 eac:	20 93 60 06 	sts	0x0660, r18	; 0x800660 <uxTopReadyPriority>
 eb0:	08 95       	ret

00000eb2 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
 eb2:	0f 93       	push	r16
 eb4:	1f 93       	push	r17
 eb6:	cf 93       	push	r28
 eb8:	df 93       	push	r29
 eba:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
 ebc:	0f b6       	in	r0, 0x3f	; 63
 ebe:	f8 94       	cli
 ec0:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 ec2:	89 2b       	or	r24, r25
 ec4:	21 f4       	brne	.+8      	; 0xece <vTaskSuspend+0x1c>
 ec6:	c0 91 b0 06 	lds	r28, 0x06B0	; 0x8006b0 <pxCurrentTCB>
 eca:	d0 91 b1 06 	lds	r29, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 ece:	8e 01       	movw	r16, r28
 ed0:	0e 5f       	subi	r16, 0xFE	; 254
 ed2:	1f 4f       	sbci	r17, 0xFF	; 255
 ed4:	c8 01       	movw	r24, r16
 ed6:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 eda:	8c 89       	ldd	r24, Y+20	; 0x14
 edc:	9d 89       	ldd	r25, Y+21	; 0x15
 ede:	89 2b       	or	r24, r25
 ee0:	21 f0       	breq	.+8      	; 0xeea <vTaskSuspend+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 ee2:	ce 01       	movw	r24, r28
 ee4:	0c 96       	adiw	r24, 0x0c	; 12
 ee6:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 eea:	b8 01       	movw	r22, r16
 eec:	84 e6       	ldi	r24, 0x64	; 100
 eee:	96 e0       	ldi	r25, 0x06	; 6
 ef0:	0e 94 82 02 	call	0x504	; 0x504 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
 ef4:	8d a1       	ldd	r24, Y+37	; 0x25
 ef6:	81 30       	cpi	r24, 0x01	; 1
 ef8:	09 f4       	brne	.+2      	; 0xefc <vTaskSuspend+0x4a>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 efa:	1d a2       	std	Y+37, r1	; 0x25
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
 efc:	0f 90       	pop	r0
 efe:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
 f00:	80 91 5f 06 	lds	r24, 0x065F	; 0x80065f <xSchedulerRunning>
 f04:	88 23       	and	r24, r24
 f06:	39 f0       	breq	.+14     	; 0xf16 <vTaskSuspend+0x64>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
 f08:	0f b6       	in	r0, 0x3f	; 63
 f0a:	f8 94       	cli
 f0c:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
 f0e:	0e 94 19 04 	call	0x832	; 0x832 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
 f12:	0f 90       	pop	r0
 f14:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
 f16:	80 91 b0 06 	lds	r24, 0x06B0	; 0x8006b0 <pxCurrentTCB>
 f1a:	90 91 b1 06 	lds	r25, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
 f1e:	c8 17       	cp	r28, r24
 f20:	d9 07       	cpc	r29, r25
 f22:	a1 f4       	brne	.+40     	; 0xf4c <vTaskSuspend+0x9a>
		{
			if( xSchedulerRunning != pdFALSE )
 f24:	80 91 5f 06 	lds	r24, 0x065F	; 0x80065f <xSchedulerRunning>
 f28:	88 23       	and	r24, r24
 f2a:	19 f0       	breq	.+6      	; 0xf32 <vTaskSuspend+0x80>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
 f2c:	0e 94 9c 03 	call	0x738	; 0x738 <vPortYield>
 f30:	0d c0       	rjmp	.+26     	; 0xf4c <vTaskSuspend+0x9a>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
 f32:	90 91 64 06 	lds	r25, 0x0664	; 0x800664 <xSuspendedTaskList>
 f36:	80 91 63 06 	lds	r24, 0x0663	; 0x800663 <uxCurrentNumberOfTasks>
 f3a:	98 13       	cpse	r25, r24
 f3c:	05 c0       	rjmp	.+10     	; 0xf48 <vTaskSuspend+0x96>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
 f3e:	10 92 b1 06 	sts	0x06B1, r1	; 0x8006b1 <pxCurrentTCB+0x1>
 f42:	10 92 b0 06 	sts	0x06B0, r1	; 0x8006b0 <pxCurrentTCB>
 f46:	02 c0       	rjmp	.+4      	; 0xf4c <vTaskSuspend+0x9a>
				}
				else
				{
					vTaskSwitchContext();
 f48:	0e 94 f3 06 	call	0xde6	; 0xde6 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 f4c:	df 91       	pop	r29
 f4e:	cf 91       	pop	r28
 f50:	1f 91       	pop	r17
 f52:	0f 91       	pop	r16
 f54:	08 95       	ret

00000f56 <_exit>:
 f56:	f8 94       	cli

00000f58 <__stop_program>:
 f58:	ff cf       	rjmp	.-2      	; 0xf58 <__stop_program>
